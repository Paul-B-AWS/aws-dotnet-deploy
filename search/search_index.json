{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About the AWS Deploy Tool for .NET AWS Deploy Tool for .NET is an interactive tooling for the .NET CLI and the AWS Toolkit for Visual Studio that helps deploy .NET applications with minimum AWS knowledge, and with the fewest clicks or commands. Key capabilities AWS Deploy Tool has the following capabilities: Compute recommendations for your application \u2013 Get recommendations about the type of compute best suited for your application based on the application type. Dockerfile generation - The tool will generate a Dockerfile if needed, otherwise an existing Dockerfile will be used. Auto packaging and deployment \u2013 The tool builds the deployment artifacts, generates a deployment CDK project, provisions the infrastructure and deploys your application to the chosen AWS compute. Repeatable and shareable deployments \u2013 You can generate and modify AWS Cloud Development Kit (CDK) deployment projects to fit your specific use case. You can also version control your projects and share them with your team for repeatable deployments. Help with learning AWS CDK for .NET! - Gradually learn the underlying AWS tools that AWS Deploy Tool for .NET is built on, such as the AWS CDK. Availability ... in .NET CLI AWS Deploy Tool for .NET is available for download as a NuGet package. See How to install section. ... in AWS Toolkit for Visual Studio The AWS Toolkit for Visual Studio exposes the same deployment functionality via Publish to AWS feature. For information about toolkit versions and using the feature, see Publish to AWS in the AWS Toolkit for Visual Studio User Guide . Additional Resources The aws-dotnet-deploy GitHub repo. Blog Post: Reimagining the AWS .NET deployment experience . Blog Post: Update on our new AWS .NET Deployment Experience . Blog Post: Deployment Projects with the new AWS .NET Deployment Experience . Video: Re:Invent 2021: \u201cWhat\u2019s new with .NET development and deployment on AWS\u201d","title":"Overview"},{"location":"#about-the-aws-deploy-tool-for-net","text":"AWS Deploy Tool for .NET is an interactive tooling for the .NET CLI and the AWS Toolkit for Visual Studio that helps deploy .NET applications with minimum AWS knowledge, and with the fewest clicks or commands.","title":"About the AWS Deploy Tool for .NET"},{"location":"#key-capabilities","text":"AWS Deploy Tool has the following capabilities: Compute recommendations for your application \u2013 Get recommendations about the type of compute best suited for your application based on the application type. Dockerfile generation - The tool will generate a Dockerfile if needed, otherwise an existing Dockerfile will be used. Auto packaging and deployment \u2013 The tool builds the deployment artifacts, generates a deployment CDK project, provisions the infrastructure and deploys your application to the chosen AWS compute. Repeatable and shareable deployments \u2013 You can generate and modify AWS Cloud Development Kit (CDK) deployment projects to fit your specific use case. You can also version control your projects and share them with your team for repeatable deployments. Help with learning AWS CDK for .NET! - Gradually learn the underlying AWS tools that AWS Deploy Tool for .NET is built on, such as the AWS CDK.","title":"Key capabilities"},{"location":"#availability","text":"","title":"Availability"},{"location":"#in-net-cli","text":"AWS Deploy Tool for .NET is available for download as a NuGet package. See How to install section.","title":"... in .NET CLI"},{"location":"#in-aws-toolkit-for-visual-studio","text":"The AWS Toolkit for Visual Studio exposes the same deployment functionality via Publish to AWS feature. For information about toolkit versions and using the feature, see Publish to AWS in the AWS Toolkit for Visual Studio User Guide .","title":"... in AWS Toolkit for Visual Studio"},{"location":"#additional-resources","text":"The aws-dotnet-deploy GitHub repo. Blog Post: Reimagining the AWS .NET deployment experience . Blog Post: Update on our new AWS .NET Deployment Experience . Blog Post: Deployment Projects with the new AWS .NET Deployment Experience . Video: Re:Invent 2021: \u201cWhat\u2019s new with .NET development and deployment on AWS\u201d","title":"Additional Resources"},{"location":"contributing/","text":"Build and Test Documentation Install Material for MkDocs Material for MkDocs is a theme for MkDocs, a static site generator geared towards (technical) project documentation. If you're familiar with Python, you can install Material for MkDocs with pip, the Python package manager. pip install mkdocs-material For, other installation options see here Deploying to a Local Server MkDocs comes with a built-in dev-server that lets you preview your documentation as you work on it. From the root of the project repository, run the following command: mkdocs serve Paste the link to the local server on a web browser to look at the documentation. The dev-server also supports auto-reloading, and will rebuild your documentation whenever anything in the configuration file, documentation directory, or theme directory changes.","title":"Contributing to the project"},{"location":"contributing/#build-and-test-documentation","text":"","title":"Build and Test Documentation"},{"location":"contributing/#install-material-for-mkdocs","text":"Material for MkDocs is a theme for MkDocs, a static site generator geared towards (technical) project documentation. If you're familiar with Python, you can install Material for MkDocs with pip, the Python package manager. pip install mkdocs-material For, other installation options see here","title":"Install Material for MkDocs"},{"location":"contributing/#deploying-to-a-local-server","text":"MkDocs comes with a built-in dev-server that lets you preview your documentation as you work on it. From the root of the project repository, run the following command: mkdocs serve Paste the link to the local server on a web browser to look at the documentation. The dev-server also supports auto-reloading, and will rebuild your documentation whenever anything in the configuration file, documentation directory, or theme directory changes.","title":"Deploying to a Local Server"},{"location":"faq/","text":"Frequently Asked Questions FAQ: I have an existing .NET application. Can I use the AWS Deploy Tool to deploy it to AWS? Yes, the AWS Deploy Tool can be used to deploy any cloud-native .NET applications to AWS. A cloud-native .NET application is written in .NET with intent to deploy to Linux, not tied to any Windows specific technology such as Windows registry, IIS or MSMQ, and can be deployed on virtualized compute. It cannot be used to deploy .NET Framework, Desktop, Xamarin, or other applications that do not fit the \u201ccloud-native\u201d criteria. FAQ: How does the AWS Deploy Tool decide what service to choose for deployment? It examines .NET project file and project dependencies, and inspects the code for attribution and Dockerfile presence to figure out the application type and the service best suited to run the application. FAQ: How will my application be packaged and deployed? Once the AWS compute service is chosen, the deployment tool will package your application binary artifacts in the appropriate format for that service (for example zip file for AWS Elastic Beanstalk) and deploy it using CDK. Once the application is deployed, it will return an endpoint for the application (for example URL for API backend, or SQS queue for messaging app). FAQ: How does the AWS Deploy Tool create infrastructure? It generates a .NET CDK project for the suggested service and uses the .NET CDK binding to build constructs. If you are not ready to learn CDK, it will auto-generate the default .NET CDK project behind the scenes. You can also change or extend the CDK project\u2019s behavior to match your exact needs and then execute the deployment. FAQ: Can I re-deploy my application to a different stack? Yes. The AWS Deploy Tool saves your deployment settings, including the environment name (such as the name of the Cloud Formation stack) your application was deployed to. When you re-run \u201cdotnet aws deploy\u201d command, it will detect these previously saved settings, and ask if you want to re-deploy to the same or a different environment. If you choose the latter, it will create a new deployment stack. FAQ: Can I choose a different AWS service to deploy my application? The AWS Deploy Tool will show you all compute service options available to deploy your application, and will recommend a default with information about why it was chosen. The other compute service options will be shown with an explanation of their differences. If the selected compute option does not match your need, you can select a different compute service. FAQ: I have an application that has dependency on Windows technology, Can I use the AWS Deploy Tool to deploy it to AWS? ASP.NET Core applications can be deployed to AWS Elastic Beanstalk picking the \"ASP.NET Core App to AWS Elastic Beanstalk on Windows\" recommendation. The deployment experience is very similar the \"ASP.NET Core App to AWS Elastic Beanstalk on Linux\" recommendation with additional settings for configuring the Internet Information Services (IIS) resource path and web site. FAQ: Can I deploy my application from Visual Studio? Yes, you can deploy your application using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio. This feature exposes the same functionality as the AWS Deploy Tool for .NET CLI. To learn more, go to Publish to AWS in the AWS Toolkit for Visual Studio User Guide. FAQ: Can I invoke AWS Deploy Tool from my CI/CD pipeline? Yes, you can. To learn more, go to Integrating with CI/CD","title":"FAQs"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#faq-i-have-an-existing-net-application-can-i-use-the-aws-deploy-tool-to-deploy-it-to-aws","text":"Yes, the AWS Deploy Tool can be used to deploy any cloud-native .NET applications to AWS. A cloud-native .NET application is written in .NET with intent to deploy to Linux, not tied to any Windows specific technology such as Windows registry, IIS or MSMQ, and can be deployed on virtualized compute. It cannot be used to deploy .NET Framework, Desktop, Xamarin, or other applications that do not fit the \u201ccloud-native\u201d criteria.","title":"FAQ: I have an existing .NET application. Can I use the AWS Deploy Tool to deploy it to AWS?"},{"location":"faq/#faq-how-does-the-aws-deploy-tool-decide-what-service-to-choose-for-deployment","text":"It examines .NET project file and project dependencies, and inspects the code for attribution and Dockerfile presence to figure out the application type and the service best suited to run the application.","title":"FAQ: How does the AWS Deploy Tool decide what service to choose for deployment?"},{"location":"faq/#faq-how-will-my-application-be-packaged-and-deployed","text":"Once the AWS compute service is chosen, the deployment tool will package your application binary artifacts in the appropriate format for that service (for example zip file for AWS Elastic Beanstalk) and deploy it using CDK. Once the application is deployed, it will return an endpoint for the application (for example URL for API backend, or SQS queue for messaging app).","title":"FAQ: How will my application be packaged and deployed?"},{"location":"faq/#faq-how-does-the-aws-deploy-tool-create-infrastructure","text":"It generates a .NET CDK project for the suggested service and uses the .NET CDK binding to build constructs. If you are not ready to learn CDK, it will auto-generate the default .NET CDK project behind the scenes. You can also change or extend the CDK project\u2019s behavior to match your exact needs and then execute the deployment.","title":"FAQ: How does the AWS Deploy Tool  create infrastructure?"},{"location":"faq/#faq-can-i-re-deploy-my-application-to-a-different-stack","text":"Yes. The AWS Deploy Tool saves your deployment settings, including the environment name (such as the name of the Cloud Formation stack) your application was deployed to. When you re-run \u201cdotnet aws deploy\u201d command, it will detect these previously saved settings, and ask if you want to re-deploy to the same or a different environment. If you choose the latter, it will create a new deployment stack.","title":"FAQ: Can I re-deploy my application to a different stack?"},{"location":"faq/#faq-can-i-choose-a-different-aws-service-to-deploy-my-application","text":"The AWS Deploy Tool will show you all compute service options available to deploy your application, and will recommend a default with information about why it was chosen. The other compute service options will be shown with an explanation of their differences. If the selected compute option does not match your need, you can select a different compute service.","title":"FAQ: Can I choose a different AWS service to deploy my application?"},{"location":"faq/#faq-i-have-an-application-that-has-dependency-on-windows-technology-can-i-use-the-aws-deploy-tool-to-deploy-it-to-aws","text":"ASP.NET Core applications can be deployed to AWS Elastic Beanstalk picking the \"ASP.NET Core App to AWS Elastic Beanstalk on Windows\" recommendation. The deployment experience is very similar the \"ASP.NET Core App to AWS Elastic Beanstalk on Linux\" recommendation with additional settings for configuring the Internet Information Services (IIS) resource path and web site.","title":"FAQ: I have an application that has dependency on Windows technology, Can I use the AWS Deploy Tool to deploy it to AWS?"},{"location":"faq/#faq-can-i-deploy-my-application-from-visual-studio","text":"Yes, you can deploy your application using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio. This feature exposes the same functionality as the AWS Deploy Tool for .NET CLI. To learn more, go to Publish to AWS in the AWS Toolkit for Visual Studio User Guide.","title":"FAQ: Can I deploy my application from Visual Studio?"},{"location":"faq/#faq-can-i-invoke-aws-deploy-tool-from-my-cicd-pipeline","text":"Yes, you can. To learn more, go to Integrating with CI/CD","title":"FAQ: Can I invoke AWS Deploy Tool from my CI/CD pipeline?"},{"location":"docs/cicd/","text":"Integrating with CI/CD You can use AWS Deploy Tool when developing your app using any Continuous Deployment system. Continuous Deployment systems let you automatically build, test and deploy your application each time you check in updates to your source code. Before you can use AWS Deploy Tool in your CD pipeline, you must have required pre-requisites installed and configured in the CD environment. Suppressing prompts with --silent To turn off the interactive features, use the -s (--silent) switch. This will ensure the tool never prompts for any questions that could block an automated process. dotnet aws deploy --silent Creating a deployment setting file To specify the services to deploy and their configurations for your environment, you need to create deployment settings file. The deployment settings file is a JSON configuration file that contains all of the settings that the deployment tool uses to drive the experience. Here is the JSON file definition . Storing deployment settings in a JSON file also allows those settings to be version controlled. Invoking from CI/CD The --apply switch on deploy command allows you to specify a deployment settings file. Deployment settings file path is always relative to the --project-path . Here's an example of a web application with the following directory structure: MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 deploymentsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln To deploy the application with above directory structure in CI/CD pipeline without any prompts, use the following command: dotnet aws deploy --silent --project-path MyWebApplication/MyWebApplication/MyWebApplication.csproj --apply deploymentsettings.json","title":"Integrating with CI/CD"},{"location":"docs/cicd/#integrating-with-cicd","text":"You can use AWS Deploy Tool when developing your app using any Continuous Deployment system. Continuous Deployment systems let you automatically build, test and deploy your application each time you check in updates to your source code. Before you can use AWS Deploy Tool in your CD pipeline, you must have required pre-requisites installed and configured in the CD environment.","title":"Integrating with CI/CD"},{"location":"docs/cicd/#suppressing-prompts-with-silent","text":"To turn off the interactive features, use the -s (--silent) switch. This will ensure the tool never prompts for any questions that could block an automated process. dotnet aws deploy --silent","title":"Suppressing prompts with --silent"},{"location":"docs/cicd/#creating-a-deployment-setting-file","text":"To specify the services to deploy and their configurations for your environment, you need to create deployment settings file. The deployment settings file is a JSON configuration file that contains all of the settings that the deployment tool uses to drive the experience. Here is the JSON file definition . Storing deployment settings in a JSON file also allows those settings to be version controlled.","title":"Creating a deployment setting file"},{"location":"docs/cicd/#invoking-from-cicd","text":"The --apply switch on deploy command allows you to specify a deployment settings file. Deployment settings file path is always relative to the --project-path . Here's an example of a web application with the following directory structure: MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 deploymentsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln To deploy the application with above directory structure in CI/CD pipeline without any prompts, use the following command: dotnet aws deploy --silent --project-path MyWebApplication/MyWebApplication/MyWebApplication.csproj --apply deploymentsettings.json","title":"Invoking from CI/CD"},{"location":"docs/support/","text":"Support Matrix The table below provides a matrix of supported .NET application types and AWS Computes. .NET Console App ASP.NET Core Blazor WebAssembly Amazon Elastic Container Service (ECS) service (Linux) Amazon Elastic Container Service (ECS) task (Linux) AWS App Runner (Linux) AWS Elastic Beanstalk (Linux and Windows) Amazon S3 & Amazon CloudFront Amazon ECS using AWS Fargate Supports deployments of .NET applications as a service (e.g. web application or a background processor) or as a scheduled task (e.g. end-of-day process) to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate serverless compute engine. Recommended if you want to deploy a service or a scheduled task as a container image on Linux. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. Amazon Elastic Container Service (Amazon ECS) is a fully managed container orchestration service that helps you easily deploy, manage, and scale containerized applications. AWS Fargate is a serverless, pay-as-you-go compute engine that lets you focus on building applications without managing servers. AWS App Runner Supports deployments of containerized ASP.NET Core applications to AWS App Runner. Recommended if you want to deploy your application as a container image on a fully managed environment. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. AWS App Runner is a fully managed service that makes it easy for developers to quickly deploy containerized web applications and APIs, at scale and with no prior infrastructure experience required. With App Runner, rather than thinking about servers or scaling, you have more time to focus on your applications. AWS Elastic Beanstalk Supports deployments of ASP.NET Core applications to AWS Elastic Beanstalk on Linux and Windows. Recommended if you want to deploy your application directly to EC2 hosts. AWS Elastic Beanstalk is an easy-to-use service for deploying and scaling web applications and services. AWS Elastic Beanstalk automatically handles the deployment, from capacity provisioning, load balancing, auto-scaling to application health monitoring. Hosting Blazor WebAssembly applications using Amazon S3 and Amazon CloudFront Blazor WebAssembly applications can be deployed to an Amazon S3 bucket for web hosting. The Amazon S3 bucket will be created and configured automatically by the tool, which will then upload your Blazor application to the S3 bucket.","title":"Support matrix"},{"location":"docs/support/#support-matrix","text":"The table below provides a matrix of supported .NET application types and AWS Computes. .NET Console App ASP.NET Core Blazor WebAssembly Amazon Elastic Container Service (ECS) service (Linux) Amazon Elastic Container Service (ECS) task (Linux) AWS App Runner (Linux) AWS Elastic Beanstalk (Linux and Windows) Amazon S3 & Amazon CloudFront","title":"Support Matrix"},{"location":"docs/support/#amazon-ecs-using-aws-fargate","text":"Supports deployments of .NET applications as a service (e.g. web application or a background processor) or as a scheduled task (e.g. end-of-day process) to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate serverless compute engine. Recommended if you want to deploy a service or a scheduled task as a container image on Linux. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. Amazon Elastic Container Service (Amazon ECS) is a fully managed container orchestration service that helps you easily deploy, manage, and scale containerized applications. AWS Fargate is a serverless, pay-as-you-go compute engine that lets you focus on building applications without managing servers.","title":"Amazon ECS using AWS Fargate"},{"location":"docs/support/#aws-app-runner","text":"Supports deployments of containerized ASP.NET Core applications to AWS App Runner. Recommended if you want to deploy your application as a container image on a fully managed environment. Note: This compute requires a Dockerfile. IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used. AWS App Runner is a fully managed service that makes it easy for developers to quickly deploy containerized web applications and APIs, at scale and with no prior infrastructure experience required. With App Runner, rather than thinking about servers or scaling, you have more time to focus on your applications.","title":"AWS App Runner"},{"location":"docs/support/#aws-elastic-beanstalk","text":"Supports deployments of ASP.NET Core applications to AWS Elastic Beanstalk on Linux and Windows. Recommended if you want to deploy your application directly to EC2 hosts. AWS Elastic Beanstalk is an easy-to-use service for deploying and scaling web applications and services. AWS Elastic Beanstalk automatically handles the deployment, from capacity provisioning, load balancing, auto-scaling to application health monitoring.","title":"AWS Elastic Beanstalk"},{"location":"docs/support/#hosting-blazor-webassembly-applications-using-amazon-s3-and-amazon-cloudfront","text":"Blazor WebAssembly applications can be deployed to an Amazon S3 bucket for web hosting. The Amazon S3 bucket will be created and configured automatically by the tool, which will then upload your Blazor application to the S3 bucket.","title":"Hosting Blazor WebAssembly applications using Amazon S3 and Amazon CloudFront"},{"location":"docs/commands/delete/","text":"delete-deployment command Usage dotnet aws delete-deployment - Tears down the application stack. Synopsis dotnet aws delete-deployment <APPLICATION-NAME> [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help] Description Tears down the application stack. Examples dotnet aws delete-deployment MY_APPLICATION --region us-west-2","title":"delete-deployment"},{"location":"docs/commands/delete/#delete-deployment-command","text":"","title":"delete-deployment command"},{"location":"docs/commands/delete/#usage","text":"dotnet aws delete-deployment - Tears down the application stack.","title":"Usage"},{"location":"docs/commands/delete/#synopsis","text":"dotnet aws delete-deployment <APPLICATION-NAME> [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help]","title":"Synopsis"},{"location":"docs/commands/delete/#description","text":"Tears down the application stack.","title":"Description"},{"location":"docs/commands/delete/#examples","text":"dotnet aws delete-deployment MY_APPLICATION --region us-west-2","title":"Examples"},{"location":"docs/commands/deploy/","text":"deploy command Usage dotnet aws deploy - Inspect, build, and deploy the .NET project to AWS using the chosen AWS compute. Synopsis dotnet aws deploy [-d|\u2014-diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [--project-path <PROJECT-PATH>] [--application-name <CLOUD-APPLICATION-NAME>] [--apply <PATH-TO-DEPLOYMENT-SETTINGS>] [--deployment-project <CDK-DEPLOYMENT-PROJECT-PATH>] [-?|-h|--help] Description Inspects the project and recommends AWS compute that is most suited to the type of deployed application. Then builds the project, generates a deployment CDK project to provision the required infrastructure, and deploys the .NET project to AWS using the chosen AWS compute. Examples Deploying HelloWorld dotnet new web -n HelloWorld -f net6.0 cd HelloWorld dotnet aws deploy Deploying application to a non-default profile dotnet aws deploy --profile myCustomProfile --region us-east1","title":"deploy"},{"location":"docs/commands/deploy/#deploy-command","text":"","title":"deploy command"},{"location":"docs/commands/deploy/#usage","text":"dotnet aws deploy - Inspect, build, and deploy the .NET project to AWS using the chosen AWS compute.","title":"Usage"},{"location":"docs/commands/deploy/#synopsis","text":"dotnet aws deploy [-d|\u2014-diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [--project-path <PROJECT-PATH>] [--application-name <CLOUD-APPLICATION-NAME>] [--apply <PATH-TO-DEPLOYMENT-SETTINGS>] [--deployment-project <CDK-DEPLOYMENT-PROJECT-PATH>] [-?|-h|--help]","title":"Synopsis"},{"location":"docs/commands/deploy/#description","text":"Inspects the project and recommends AWS compute that is most suited to the type of deployed application. Then builds the project, generates a deployment CDK project to provision the required infrastructure, and deploys the .NET project to AWS using the chosen AWS compute.","title":"Description"},{"location":"docs/commands/deploy/#examples","text":"Deploying HelloWorld dotnet new web -n HelloWorld -f net6.0 cd HelloWorld dotnet aws deploy Deploying application to a non-default profile dotnet aws deploy --profile myCustomProfile --region us-east1","title":"Examples"},{"location":"docs/commands/list/","text":"list-deployments command Usage dotnet aws list-deployments - Lists available cloud applications that were deployed using AWS Deploy Tool Synopsis dotnet new list-deployments [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help] Description Lists available cloud applications that were deployed using AWS Deploy Tool. Examples dotnet aws list-deployments --region us-west-2","title":"list-deployments"},{"location":"docs/commands/list/#list-deployments-command","text":"","title":"list-deployments command"},{"location":"docs/commands/list/#usage","text":"dotnet aws list-deployments - Lists available cloud applications that were deployed using AWS Deploy Tool","title":"Usage"},{"location":"docs/commands/list/#synopsis","text":"dotnet new list-deployments [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [-?|-h|--help]","title":"Synopsis"},{"location":"docs/commands/list/#description","text":"Lists available cloud applications that were deployed using AWS Deploy Tool.","title":"Description"},{"location":"docs/commands/list/#examples","text":"dotnet aws list-deployments --region us-west-2","title":"Examples"},{"location":"docs/commands/project/","text":"deployment-project generate command Usage dotnet aws deployment-project - Generates and saves the deployment CDK project in the user provided location. Synopsis dotnet aws deployment-project generate [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [--project-path <PROJECT-PATH>] [--project-display-name <DISPLAY-NAME>] Description Generates and saves the deployment CDK project in a user provided directory path without proceeding with a deployment. Allows user to customize the CDK project before deploying the application. The --output switch sets the directory where the deployment project will be saved. The --project-display-name switch sets the name that will be shown when the .NET project is being deployed. Examples This example creates a deployment project from the .NET project in the current directory. The deployment project will be saved to a sibling directory called CustomDeploymentProject. The name \"Team custom deployment project\" will be displayed in the list of the available deployment options. dotnet aws deployment-project generate --output ../CustomDeploymentProject --project-display-name \"Team custom deployment project\"","title":"deployment-project"},{"location":"docs/commands/project/#deployment-project-generate-command","text":"","title":"deployment-project generate command"},{"location":"docs/commands/project/#usage","text":"dotnet aws deployment-project - Generates and saves the deployment CDK project in the user provided location.","title":"Usage"},{"location":"docs/commands/project/#synopsis","text":"dotnet aws deployment-project generate [-d|--diagnostics] [-s|--silent] [--profile <PROFILE>] [--region <REGION>] [--project-path <PROJECT-PATH>] [--project-display-name <DISPLAY-NAME>]","title":"Synopsis"},{"location":"docs/commands/project/#description","text":"Generates and saves the deployment CDK project in a user provided directory path without proceeding with a deployment. Allows user to customize the CDK project before deploying the application. The --output switch sets the directory where the deployment project will be saved. The --project-display-name switch sets the name that will be shown when the .NET project is being deployed.","title":"Description"},{"location":"docs/commands/project/#examples","text":"This example creates a deployment project from the .NET project in the current directory. The deployment project will be saved to a sibling directory called CustomDeploymentProject. The name \"Team custom deployment project\" will be displayed in the list of the available deployment options. dotnet aws deployment-project generate --output ../CustomDeploymentProject --project-display-name \"Team custom deployment project\"","title":"Examples"},{"location":"docs/commands/server-mode/","text":"server-mode command Usage dotnet aws server-mode - Launches the tool in a server mode for integrations with IDE, for example Visual Studio. Synopsis dotnet aws server-mode [-d|--diagnostics] [-s|--silent] [-?|-h|--help] [--port <PORT>] [--parent-pid <PARENT-PID>] [--unsecure-mode] Description Starts the tool in the server mode to provide integration with IDEs, for example Visual Studio. This tool is not intended for the end user usage unless you are writing a custom integration into an IDE. Examples dotnet aws server-mode --port 1234 --parent-pid 12345","title":"server-mode"},{"location":"docs/commands/server-mode/#server-mode-command","text":"","title":"server-mode command"},{"location":"docs/commands/server-mode/#usage","text":"dotnet aws server-mode - Launches the tool in a server mode for integrations with IDE, for example Visual Studio.","title":"Usage"},{"location":"docs/commands/server-mode/#synopsis","text":"dotnet aws server-mode [-d|--diagnostics] [-s|--silent] [-?|-h|--help] [--port <PORT>] [--parent-pid <PARENT-PID>] [--unsecure-mode]","title":"Synopsis"},{"location":"docs/commands/server-mode/#description","text":"Starts the tool in the server mode to provide integration with IDEs, for example Visual Studio. This tool is not intended for the end user usage unless you are writing a custom integration into an IDE.","title":"Description"},{"location":"docs/commands/server-mode/#examples","text":"dotnet aws server-mode --port 1234 --parent-pid 12345","title":"Examples"},{"location":"docs/deployment-projects/","text":"Deployment Projects What is a deployment recipe? The tool provides intelligent deployment recommendations that are tailored to your specific .NET application. The recommendation rules are defined in the deployment recipes . These recipes let you configure a pre-defined set of AWS resources related to your application such as IAM roles, virtual private clouds, load balancers, and other. There is a built-in recipe for each supported project type . All recipe definitions are available on GitHub . What is a deployment project? What if your application uses additional AWS resources that are not included in the built-in recipe, such as DynamoDB tables or SQS queues? In this case, you can extend one of the existing recipes and create a custom deployment project to manage additional AWS resources and services. Once you create and customize your deployment project, it will be displayed alongside the built-in recipes as a custom deployment option. Before: The recommended deployment target is a built-in recipe for ASP.NET Core applications. After: The recommended deployment target is a custom deployment project that manages a DynamoDB table in addition to the ASP.NET Core project. Parts of a deployment project A deployment project consists of two parts. For details, refer to the full reference guides below. Recipe file - a JSON configuration file that drives the deployment experience. .NET CDK project - a C# project that uses the AWS Cloud Development Kit (CDK) to define the infrastructure that will be created. Creating a deployment project To create a custom deployment project, run this command in the directory of the .NET project you wish to deploy. See deployment-project command for more details. dotnet aws deployment-project generate --output <output-directory> --project-display-name <display-name> The list of built-in recipes that are compatible with your .NET project will be displayed. Select the recipe that you will use to customize, and a deployment project will be created in the --output directory. Note: It is important to add your deployment projects to source control. If your deployment project has been deleted, you will not be able to re-deploy your application to the same CloudFormation stack. Now you can begin customizing the deployment project. See our step-by-step tutorial for a step-by-step instructions. Searching for deployment projects When you run the dotnet aws deploy command, the tool searches for deployment projects anywhere underneath the solution (.sln) directory of project you are deploying. It also ensures that each deployment project iscompatible with the .NET project being deployed. To point to a deployment project that is outside the solution directory, use the --deployment-project switch to pass in the path of the deployment project to use. This is common when sharing deployment projects across multiple solutions.","title":"Overview"},{"location":"docs/deployment-projects/#deployment-projects","text":"","title":"Deployment Projects"},{"location":"docs/deployment-projects/#what-is-a-deployment-recipe","text":"The tool provides intelligent deployment recommendations that are tailored to your specific .NET application. The recommendation rules are defined in the deployment recipes . These recipes let you configure a pre-defined set of AWS resources related to your application such as IAM roles, virtual private clouds, load balancers, and other. There is a built-in recipe for each supported project type . All recipe definitions are available on GitHub .","title":"What is a deployment recipe?"},{"location":"docs/deployment-projects/#what-is-a-deployment-project","text":"What if your application uses additional AWS resources that are not included in the built-in recipe, such as DynamoDB tables or SQS queues? In this case, you can extend one of the existing recipes and create a custom deployment project to manage additional AWS resources and services. Once you create and customize your deployment project, it will be displayed alongside the built-in recipes as a custom deployment option. Before: The recommended deployment target is a built-in recipe for ASP.NET Core applications. After: The recommended deployment target is a custom deployment project that manages a DynamoDB table in addition to the ASP.NET Core project.","title":"What is a deployment project?"},{"location":"docs/deployment-projects/#parts-of-a-deployment-project","text":"A deployment project consists of two parts. For details, refer to the full reference guides below. Recipe file - a JSON configuration file that drives the deployment experience. .NET CDK project - a C# project that uses the AWS Cloud Development Kit (CDK) to define the infrastructure that will be created.","title":"Parts of a deployment project"},{"location":"docs/deployment-projects/#creating-a-deployment-project","text":"To create a custom deployment project, run this command in the directory of the .NET project you wish to deploy. See deployment-project command for more details. dotnet aws deployment-project generate --output <output-directory> --project-display-name <display-name> The list of built-in recipes that are compatible with your .NET project will be displayed. Select the recipe that you will use to customize, and a deployment project will be created in the --output directory. Note: It is important to add your deployment projects to source control. If your deployment project has been deleted, you will not be able to re-deploy your application to the same CloudFormation stack. Now you can begin customizing the deployment project. See our step-by-step tutorial for a step-by-step instructions.","title":"Creating a deployment project"},{"location":"docs/deployment-projects/#searching-for-deployment-projects","text":"When you run the dotnet aws deploy command, the tool searches for deployment projects anywhere underneath the solution (.sln) directory of project you are deploying. It also ensures that each deployment project iscompatible with the .NET project being deployed. To point to a deployment project that is outside the solution directory, use the --deployment-project switch to pass in the path of the deployment project to use. This is common when sharing deployment projects across multiple solutions.","title":"Searching for deployment projects"},{"location":"docs/deployment-projects/cdk-project/","text":"CDK Project Each deployment project has a C# Cloud Development Kit (CDK) project. This CDK project is used to create the AWS infrastructure as a CloudFormation stack based on the user settings and to deploy your project to that infrastructure. Read our tutorial to see how you can customize this CDK project to add additional infrastructure resources for your deployments. What is AWS CDK? The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages. The following links are useful resources to learn more about AWS CDK and how to write .NET CDK projects. AWS CDK Developer Guide .NET CDK Workshop .NET CDK Reference Layout of a CDK deployment project The layout of the generated CDK project puts all the code that was used to create the AWS resources defined in the starting recipe in a directory called Generated . It is recommended to not modify the code in the Generated directory to make it easier to merge future changes from the starting recipe into your custom deployment project. If you do not intend to update your custom deployment project from the original built-in recipe you may modify the code or rearrange the directory layout. If you choose to not modify the Generated code it is recommended to customize the CDK project starting from the AppStack class. Here is the constructor of AppStack . internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; // Create custom CDK constructs here that might need to be referenced in the CustomizeCDKProps. For example if // creating a DynamoDB table construct and then later using the CDK construct reference in CustomizeCDKProps to // pass the table name as an environment variable to the container image. // Create the recipe defined CDK construct with all of its sub constructs. var generatedRecipe = new Recipe(this, props.RecipeProps); // Create additional CDK constructs here. The recipe's constructs can be accessed as properties on // the generatedRecipe variable. } The var generatedRecipe = new Recipe(this, props.RecipeProps); line of code creates all of the AWS resources from the Generated directory. Your customizations could create new AWS resources via CDK constructs before or after this line. Typically you would create new resources before this line if you want those resources to be connected to the resources defined in the Recipe type. If you need to create new resources that are connected to the resources defined in the Recipe then create them after this line. The instance of Recipe has public properties for all of the resources that were created in the Recipe . In this constructor a callback method called CustomizeCDKProps is setup. This callback method is called right before any constructs are created from the Recipe . This allows modifying the construct's property object before it is passed into the construct. The example below shows the CustomizeCDKProps callback that checks to see if the resource being created is the Beanstalk Environment. If it is, cast the property object to the appropriate property object and then make whatever customizations are needed. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.BeanstalkEnvironment))) { if (evnt.Props is CfnEnvironmentProps props) { Console.WriteLine(\"Customizing Beanstalk Environment\"); } } } Main method in Program.cs The Main method in Program.cs for the CDK deployment project must be coded in a certain style to ensure compatibility with the deploy tool. The AWS Deploy Tool relies on .NET's Configuration system to pass along settings from the deploy tool to the CDK project. In the example below the ConfigurationBuilder().AddAWSDeployToolConfiguration(app) method reads the settings that were passed into the project from the deploy tool. With the configuration read from the deploy tool, the CDK environment is set to the account and region the deploy tool was configured with. The other major difference from normal CDK projects is the call to CDKRecipeSetup.RegisterStack . This is required to stamp the CloudFormation stack with the recipe id that created the stack. Future redeployments can only update existing stacks that were created by the original recipe. It also serializes the settings collected from the deploy tool into the metadata for the CloudFormation stack so redeployments can use the previous settings used for deployment. public static void Main(string[] args) { var app = new App(); var builder = new ConfigurationBuilder().AddAWSDeployToolConfiguration(app); var recipeProps = builder.Build().Get<RecipeProps<Configuration>>(); var appStackProps = new DeployToolStackProps<Configuration>(recipeProps) { Env = new Environment { Account = recipeProps.AWSAccountId, Region = recipeProps.AWSRegion } }; // The RegisterStack method is used to set identifying information on the stack // for the recipe used to deploy the application and preserve the settings used in the recipe // to allow redeployment. The information is stored as CloudFormation tags and metadata inside // the generated CloudFormation template. CDKRecipeSetup.RegisterStack<Configuration>(new AppStack(app, appStackProps), appStackProps.RecipeProps); app.Synth(); } Configuration options The option settings that are defined in the recipe file are passed into the CDK project and then deserialized into the Configuration object. When you add new settings to the recipe file, you also need to add the Id of the new settings to the Configuration object. If you added an Object setting with a collection of child settings, first create a new type representing that entire Object . For reach child setting id, add a property on the new type. Finally, add a new property on Configuration for your new type with the property name being the id of the Object setting. The Configuration object follows the same Generated directory pattern described above. Custom settings should be added to the partial Configuration.cs file outside of the Generated directory.","title":"CDK Project"},{"location":"docs/deployment-projects/cdk-project/#cdk-project","text":"Each deployment project has a C# Cloud Development Kit (CDK) project. This CDK project is used to create the AWS infrastructure as a CloudFormation stack based on the user settings and to deploy your project to that infrastructure. Read our tutorial to see how you can customize this CDK project to add additional infrastructure resources for your deployments.","title":"CDK Project"},{"location":"docs/deployment-projects/cdk-project/#what-is-aws-cdk","text":"The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework to define your cloud application resources using familiar programming languages. The following links are useful resources to learn more about AWS CDK and how to write .NET CDK projects. AWS CDK Developer Guide .NET CDK Workshop .NET CDK Reference","title":"What is AWS CDK?"},{"location":"docs/deployment-projects/cdk-project/#layout-of-a-cdk-deployment-project","text":"The layout of the generated CDK project puts all the code that was used to create the AWS resources defined in the starting recipe in a directory called Generated . It is recommended to not modify the code in the Generated directory to make it easier to merge future changes from the starting recipe into your custom deployment project. If you do not intend to update your custom deployment project from the original built-in recipe you may modify the code or rearrange the directory layout. If you choose to not modify the Generated code it is recommended to customize the CDK project starting from the AppStack class. Here is the constructor of AppStack . internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; // Create custom CDK constructs here that might need to be referenced in the CustomizeCDKProps. For example if // creating a DynamoDB table construct and then later using the CDK construct reference in CustomizeCDKProps to // pass the table name as an environment variable to the container image. // Create the recipe defined CDK construct with all of its sub constructs. var generatedRecipe = new Recipe(this, props.RecipeProps); // Create additional CDK constructs here. The recipe's constructs can be accessed as properties on // the generatedRecipe variable. } The var generatedRecipe = new Recipe(this, props.RecipeProps); line of code creates all of the AWS resources from the Generated directory. Your customizations could create new AWS resources via CDK constructs before or after this line. Typically you would create new resources before this line if you want those resources to be connected to the resources defined in the Recipe type. If you need to create new resources that are connected to the resources defined in the Recipe then create them after this line. The instance of Recipe has public properties for all of the resources that were created in the Recipe . In this constructor a callback method called CustomizeCDKProps is setup. This callback method is called right before any constructs are created from the Recipe . This allows modifying the construct's property object before it is passed into the construct. The example below shows the CustomizeCDKProps callback that checks to see if the resource being created is the Beanstalk Environment. If it is, cast the property object to the appropriate property object and then make whatever customizations are needed. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.BeanstalkEnvironment))) { if (evnt.Props is CfnEnvironmentProps props) { Console.WriteLine(\"Customizing Beanstalk Environment\"); } } }","title":"Layout of a CDK deployment project"},{"location":"docs/deployment-projects/cdk-project/#main-method-in-programcs","text":"The Main method in Program.cs for the CDK deployment project must be coded in a certain style to ensure compatibility with the deploy tool. The AWS Deploy Tool relies on .NET's Configuration system to pass along settings from the deploy tool to the CDK project. In the example below the ConfigurationBuilder().AddAWSDeployToolConfiguration(app) method reads the settings that were passed into the project from the deploy tool. With the configuration read from the deploy tool, the CDK environment is set to the account and region the deploy tool was configured with. The other major difference from normal CDK projects is the call to CDKRecipeSetup.RegisterStack . This is required to stamp the CloudFormation stack with the recipe id that created the stack. Future redeployments can only update existing stacks that were created by the original recipe. It also serializes the settings collected from the deploy tool into the metadata for the CloudFormation stack so redeployments can use the previous settings used for deployment. public static void Main(string[] args) { var app = new App(); var builder = new ConfigurationBuilder().AddAWSDeployToolConfiguration(app); var recipeProps = builder.Build().Get<RecipeProps<Configuration>>(); var appStackProps = new DeployToolStackProps<Configuration>(recipeProps) { Env = new Environment { Account = recipeProps.AWSAccountId, Region = recipeProps.AWSRegion } }; // The RegisterStack method is used to set identifying information on the stack // for the recipe used to deploy the application and preserve the settings used in the recipe // to allow redeployment. The information is stored as CloudFormation tags and metadata inside // the generated CloudFormation template. CDKRecipeSetup.RegisterStack<Configuration>(new AppStack(app, appStackProps), appStackProps.RecipeProps); app.Synth(); }","title":"Main method in Program.cs"},{"location":"docs/deployment-projects/cdk-project/#configuration-options","text":"The option settings that are defined in the recipe file are passed into the CDK project and then deserialized into the Configuration object. When you add new settings to the recipe file, you also need to add the Id of the new settings to the Configuration object. If you added an Object setting with a collection of child settings, first create a new type representing that entire Object . For reach child setting id, add a property on the new type. Finally, add a new property on Configuration for your new type with the property name being the id of the Object setting. The Configuration object follows the same Generated directory pattern described above. Custom settings should be added to the partial Configuration.cs file outside of the Generated directory.","title":"Configuration options"},{"location":"docs/deployment-projects/recipe-file/","text":"Recipe file schema Each deployment project has a JSON file with a .recipe extension. This recipe file defines the type of .NET projects the recipe is compatible with and the settings that will be shown to users. Read our tutorial to see how you can modify this file to drive the custom deployment experience and display custom option settings to the users. The full schema for the recipe file can be found here . Top level settings This is the list of top level properties in the recipe definition. Id - the Id of the deployment project. The CloudFormation stack will be tagged with this Id which is used to identify which stacks to update when redeploying. Name - the name of the deployment project, shown in the list of recommendations. ShortDescription - description used when showing the list of recommendations. Description - longer description shown when hovering over the recommendation in Visual Studio. TargetService - the main AWS service the application will be deployed to. Visual Studio uses this to provide visual indicators. DeploymentType - for deployment projects this value should always be CdkProject . DeploymentBundle - how the .NET project being deploying should be bundled. Allowed values are Container and DotnetPublishZipFile . DisplayedResources - the list of resources to display to users at the end of the deployment. RecipePriority - the priority of the recipe in the compatibility list. RecommendationRules - the list of rules to determine the recipe's compatibility with the project being deployed. Categories - the list of categories for the option settings. OptionSettings - the list of settings users can configure during deployment. Displayed Resources The DisplayedResources array contains a list of resources that the deployment tooling should display after deployment is complete. This is typically the primary resources for a deployment project like an Elastic Beanstalk Environment or a Load Balancer that allows the user to quickly see their application deployed to AWS. Here is an example for a recipe that wants to the Elastic Beanstalk environment to be displayed after deployment. \"DisplayedResources\": [ { \"LogicalId\": \"RecipeBeanstalkEnvironment83CC12DE\", \"Description\": \"Application Endpoint\" } ], DisplayedResources objects have the following properties: LogicalId - the CloudFormation logical id of the AWS resource. The CDK will generate a unique hash as the suffix of the logical resource id. The easiest way to figure out the value to set here is to do an initial deployment of the deployment project and then look up the logical id in the CloudFormation console. Description - a description for the resource shown to users in the list of display resources. Compatibility Rules The recipe file defines a collection of rules that the deployment tool executes against the .NET project being deployed to determine if the recipe is compatible with the .NET project. A rule is made up of a list of tests to run and the effect to apply. Tests The deploy tool supports a collection of tests that can be run against the .NET project being deployed. Here is an example of a test that checks the version of .NET the project is targeting. { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } The Type property determines the type of test to run. The Condition contains the data needed to evaluate the test, in this case the MSBuild property to check and the allowed values. Each type of test can have a different set of properties for the Condition . Available Tests Type Description Conditions properties MSProjectSdkAttribute Compares the Sdk attribute at the root element of the project file to a given value. Value - the expected value. For example Microsoft.NET.Sdk.Web for web projects. MSProperty Compares the property in a project file property group. PropertyName - the property to compare. AllowedValues - an array of possible values for the property. MSPropertyExists Test to see if a property in a property group exists. PropertyName - the property test for existence. FileExists Tests to see if a file exist. For example checking to see a Dockerfile exists. FileName - the file to test for existence. NuGetPackageReference Test to see if the project has a PackageReference to a NuGet package. NuGetPackageName - the NuGet package to test if it is being referenced. Effect A rules effect defines the behavior of the rule depending on if its test(s) pass or not. Effects can either mark the recipe as not included in the compatible list or adjust the priority for the recipe. Here is an example of a rule that checks the project is a web project and targets .NET Core 3.1 or .NET 6. If both tests pass the effect's Pass property instructs the deployment tooling to include the recipe. If either one of the two tests fail the Fail effect is run, removing the recipe from the included compatible list. \"RecommendationRules\": [ { \"Tests\": [ { \"Type\": \"MSProjectSdkAttribute\", \"Condition\": { \"Value\": \"Microsoft.NET.Sdk.Web\" } }, { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } ], \"Effect\": { \"Pass\": { \"Include\": true }, \"Fail\": { \"Include\": false } } } ] Here is another example that tests if a project contains a docker file. If it does not include a docker file it reduces the priority of the recipe. \"RecommendationRules\": [ ... { \"Tests\": [ { \"Type\": \"FileExists\", \"Condition\": { \"FileName\": \"Dockerfile\" } } ], \"Effect\": { \"Fail\": { \"PriorityAdjustment\": -100, \"Include\": true } } }, ... ] A recipe is considered compatible if no rule ran an effect that set Include to false and if the priority is greater then 0. To simulate an \"or\" set of rules the starting priority in RecipePriority can be set to a negative value meaning it is not included by default. Then you can have a series of tests that adjust the priority to a positive amount. That way if any test rule passes it can adjust the priority to a positive number. Setting Categories The Categories property is an array of objects that define the categories for the settings. The AWS Toolkit for Visual Studio uses this array to build the list of categories in the UI for fast navigation to a group of settings. A category is defined with the following properties: Id - the unique id within the recipe for the category. DisplayName - the name of the category displayed to users. Order - the order in the toolkit for the category. Categories are display in sorted descending order. Here is an example of defining a custom category that you could use to categorize additional settings added as application resources. { \"Id\": \"AppResources\", \"DisplayName\": \"Application Resources\", \"Order\": 15 } To assign a setting to a category, set the setting's Category property of to the Id of a category. Only top level settings can be assigned a category. Any top level settings that are not assigned a category will be placed in the General category. Option Settings The settings that are shown to users and allows users to customize the deployment in either the CLI or Visual Studio are defined in the OptionSettings array. Settings have the following properties. Id - the id of the setting. Once projects are deployed with the recipe, this id should not change because the id is saved into the CloudFormation stack's template. Name - the name of the setting shown to users. Description - the informational text shown to users for the setting. Type - the data type of the setting. DefaultValue - the default value for the setting. TypeHint - a hint to the deployment tooling what the meaning of the setting is. TypeHintData - additional information to pass into the type hint. AdvancedSetting - a boolean for whether this setting is an advanced use case. If true the setting might not be shown to users unless the request to see all settings. Updatable - a boolean that controls whether a setting can be modified during redeployment. It is recommended to set this to false for settings where deleting resources once they exist would make the application unavailable. AllowedValues - the list of possible values. ValueMapping - a mapping between values in the AllowedValues list to user friendly display names for each allowed value. ChildOptionSettings - if the Type property is set to Object this list contains a child option settings. DependsOn - a list of expressions to determine if this setting should be visible. Validators - a list of validators to run when values are set for the setting to ensure the value is valid. ParentSettingId - the id of a setting that represents the parent of this setting. For example a setting that allows picking EC2 subnets would set the ParentSettingId to the setting that defines the VPC to use for deployment. The type hint for the setting can use this field to filter the list of subnets that are valid for the selected VPC. Setting Data Types Settings can have the following data types: String Int Double Bool KeyValue List Object If the data type is set to Object the setting has child settings that are defined in the ChildOptionSettings array for the setting. TypeHint Type hints are used to control the user experience in the CLI or Visual Studio. For example if the TypeHint property is set to ExistingECSCluster the deployment tool knows this String data type setting should be set to the name of an existing ECS cluster and presents the list of existing clusters to the user. Some type hints require additional configuration which can specified in the TypeHintData property. For example if a setting has a type hint of ExistingIAMRole the tool should only show roles that can be assumed by the target service. Here is a example of configuring the ServicePrincipal for the type hint to filter the list of roles to pick from. { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"ecs-tasks.amazonaws.com\" }, ... Here is the list of available type hints in the deployment tooling. Type Hint Type Hint Data Notes IAMRole ServicePrincipal - the service principal the role can be assumed by. Set at Object level that controls whether to create a new role or select an existing role. ExistingIAMRole ServicePrincipal - the service principal the role can be assumed by. Set at the String setting level for storing the existing IAM role arn. ECSCluster Set at the Object setting level that controls whether to create or select an existing ECS cluster. ExistingECSCluster Set at the String setting level for storing the existing ECS Cluster Name. ECSService ECSTaskSchedule EC2KeyPair Vpc Set at the Object level that controls whether to create a new VPC or select an existing VPC. ExistingVpc Set at the String setting level for storing the existing VPC ID. AppRunnerService VPCConnector Set at the Object level for creating or selecting an App Runner VPC Connector. ExistingVpcConnector Set at the String setting level for storing the existing VPC Connector id. BeanstalkRollingUpdates ExistingSubnets ParentSettingId should be set to a setting for the VPC. ExistingSecurityGroups ParentSettingId should be set to a setting for the VPC. ExistingBeanstalkApplication ExistingApplicationLoadBalancer InstanceType WindowsInstanceType S3BucketName AllowNoValue - determines whether to allow no value to be set. DynamoDBTableName AllowNoValue - determines whether to allow no value to be set. SQSQueueUrl AllowNoValue - determines whether to allow no value to be set. SNSTopicArn AllowNoValue - determines whether to allow no value to be set. FilePath Filter - the filter that appears in the file dialog box. DefaultExtension - the default extension used if the user specifies a file name without an extension. Title - the title of the file dialog box. CheckFileExists - if true the deployment tooling ensures the file exists. AllowEmpty - controls whether an empty value is allowed. DotnetBeanstalkPlatformArn DotnetWindowsBeanstalkPlatformArn DotnetPublishSelfContainedBuild Used internally to validate build configuration. DotnetPublishBuildConfiguration Used internally to validate build configuration. DotnetPublishAdditionalBuildArguments Used internally to validate build configuration. DockerExecutionDirectory Used internally to validate build configuration. DockerBuildArgs Used internally to validate build configuration. DependsOn The DependsOn property is an array of conditions to determine if a setting should be visible based on the values for other setting(s). For example if a user selects the setting to create a new IAM role then the setting for the selecting an existing IAM role should not be displayed. Each item in the DependsOn array has the following properties. Id - the id of the setting compare. The id should be full id including all parent object id settings. The format is . . Operation - the operation to run. Allowed values are NotEmpty and Equals . If operation is not set then the default is Equals . Value - the value to compare when the operation is Equals . Here is an example for a setting used for storing an existing IAM role to use. The value is displayed if the setting ApplicationIAMRole.CreateNew is set false. { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"tasks.apprunner.amazonaws.com\" }, \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"ApplicationIAMRole.CreateNew\", \"Value\": false } ], ... } Validators Validators allow telling the user when a setting has an invalid value before starting the deployment. Each setting can have a list of validators specified in the Validators array. Validators can do simple checks like making sure string values are of a certain format as well as make AWS service calls to make sure the value of an existing resource exists. Here is an example of a validator for a port setting that ensures the value is within the range 0 to 51200. ... { \"Id\": \"Port\", \"Name\": \"Port\", \"Category\": \"General\", \"Description\": \"The port the container is listening for requests on.\", \"Type\": \"Int\", \"DefaultValue\": 80, \"AdvancedSetting\": false, \"Updatable\": true, \"Validators\": [ { \"ValidatorType\": \"Range\", \"Configuration\": { \"Min\": 0, \"Max\": 51200 } } ] } ... The ValidatorType property determines the type of validator to run. The Configuration contains the data needed to evaluate the validator, in this case the min and max values. Each type of validator can have a different set of properties for the Configuration . Validator Type Description Configuration properties Range For numeric settings define the min and max values. Min - the min value. Max - the max value. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Regex For string settings define a regular expression that the value must match. Regex - the regular expression to match against the value of the setting. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Required A value is required for the setting. ValidationFailedMessage - the error message shown if the validator fails. DirectoryExists For string settings representing a directory. Validates the directory exists. DockerBuildArgs Ensures the value is valid for being passed to the docker build command. DotnetPublishArgs Ensures the value is valid for being passed to the dotnet publish command. ExistingResource Using the AWS Cloud Control API GetResource , ensure that the AWS resource exists. ResourceType - the AWS resource type to search for. For example AWS::ECS::Cluster for an ECS cluster. FileExists For string settings representing a file path. Validates the file exists. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. StringLength Validates the length of a string setting. MinLength - the min length for the string. MaxLength - the max length for the string. ValidationFailedMessage - the error message shown if the validator fails. InstanceType Validates the string value is a valid Linux EC2 instance type. WindowsInstanceType Validates the string value is a valid Windows EC2 instance type. SubnetsInVpc Validates the subnets are in the configured VPC. VpcId - the id of the setting that has the VPC configured for. ValidationFailedMessage - the error message shown if the validator fails. SecurityGroupsInVpc Validates the security group are in the configured VPC. VpcId - the id of the setting that has the VPC configured for. ValidationFailedMessage - the error message shown if the validator fails. Uri Validates the value is a well-formed URI string. ValidationFailedMessage - the error message shown if the validator fails. Comparison Compares this setting with another setting. SettingId - the setting to compare to. Operation - the comparison operation. Allowed values are GreaterThan . VPCSubnetsInDifferentAZs Validates that the selected VPC must have at least two subnets in two different Availability Zones ValidationFailedMessage - the error message shown if the validator fails.","title":"Recipe File"},{"location":"docs/deployment-projects/recipe-file/#recipe-file-schema","text":"Each deployment project has a JSON file with a .recipe extension. This recipe file defines the type of .NET projects the recipe is compatible with and the settings that will be shown to users. Read our tutorial to see how you can modify this file to drive the custom deployment experience and display custom option settings to the users. The full schema for the recipe file can be found here .","title":"Recipe file schema"},{"location":"docs/deployment-projects/recipe-file/#top-level-settings","text":"This is the list of top level properties in the recipe definition. Id - the Id of the deployment project. The CloudFormation stack will be tagged with this Id which is used to identify which stacks to update when redeploying. Name - the name of the deployment project, shown in the list of recommendations. ShortDescription - description used when showing the list of recommendations. Description - longer description shown when hovering over the recommendation in Visual Studio. TargetService - the main AWS service the application will be deployed to. Visual Studio uses this to provide visual indicators. DeploymentType - for deployment projects this value should always be CdkProject . DeploymentBundle - how the .NET project being deploying should be bundled. Allowed values are Container and DotnetPublishZipFile . DisplayedResources - the list of resources to display to users at the end of the deployment. RecipePriority - the priority of the recipe in the compatibility list. RecommendationRules - the list of rules to determine the recipe's compatibility with the project being deployed. Categories - the list of categories for the option settings. OptionSettings - the list of settings users can configure during deployment.","title":"Top level settings"},{"location":"docs/deployment-projects/recipe-file/#displayed-resources","text":"The DisplayedResources array contains a list of resources that the deployment tooling should display after deployment is complete. This is typically the primary resources for a deployment project like an Elastic Beanstalk Environment or a Load Balancer that allows the user to quickly see their application deployed to AWS. Here is an example for a recipe that wants to the Elastic Beanstalk environment to be displayed after deployment. \"DisplayedResources\": [ { \"LogicalId\": \"RecipeBeanstalkEnvironment83CC12DE\", \"Description\": \"Application Endpoint\" } ], DisplayedResources objects have the following properties: LogicalId - the CloudFormation logical id of the AWS resource. The CDK will generate a unique hash as the suffix of the logical resource id. The easiest way to figure out the value to set here is to do an initial deployment of the deployment project and then look up the logical id in the CloudFormation console. Description - a description for the resource shown to users in the list of display resources.","title":"Displayed Resources"},{"location":"docs/deployment-projects/recipe-file/#compatibility-rules","text":"The recipe file defines a collection of rules that the deployment tool executes against the .NET project being deployed to determine if the recipe is compatible with the .NET project. A rule is made up of a list of tests to run and the effect to apply.","title":"Compatibility Rules"},{"location":"docs/deployment-projects/recipe-file/#tests","text":"The deploy tool supports a collection of tests that can be run against the .NET project being deployed. Here is an example of a test that checks the version of .NET the project is targeting. { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } The Type property determines the type of test to run. The Condition contains the data needed to evaluate the test, in this case the MSBuild property to check and the allowed values. Each type of test can have a different set of properties for the Condition .","title":"Tests"},{"location":"docs/deployment-projects/recipe-file/#available-tests","text":"Type Description Conditions properties MSProjectSdkAttribute Compares the Sdk attribute at the root element of the project file to a given value. Value - the expected value. For example Microsoft.NET.Sdk.Web for web projects. MSProperty Compares the property in a project file property group. PropertyName - the property to compare. AllowedValues - an array of possible values for the property. MSPropertyExists Test to see if a property in a property group exists. PropertyName - the property test for existence. FileExists Tests to see if a file exist. For example checking to see a Dockerfile exists. FileName - the file to test for existence. NuGetPackageReference Test to see if the project has a PackageReference to a NuGet package. NuGetPackageName - the NuGet package to test if it is being referenced.","title":"Available Tests"},{"location":"docs/deployment-projects/recipe-file/#effect","text":"A rules effect defines the behavior of the rule depending on if its test(s) pass or not. Effects can either mark the recipe as not included in the compatible list or adjust the priority for the recipe. Here is an example of a rule that checks the project is a web project and targets .NET Core 3.1 or .NET 6. If both tests pass the effect's Pass property instructs the deployment tooling to include the recipe. If either one of the two tests fail the Fail effect is run, removing the recipe from the included compatible list. \"RecommendationRules\": [ { \"Tests\": [ { \"Type\": \"MSProjectSdkAttribute\", \"Condition\": { \"Value\": \"Microsoft.NET.Sdk.Web\" } }, { \"Type\": \"MSProperty\", \"Condition\": { \"PropertyName\": \"TargetFramework\", \"AllowedValues\": [ \"netcoreapp3.1\", \"net6.0\" ] } } ], \"Effect\": { \"Pass\": { \"Include\": true }, \"Fail\": { \"Include\": false } } } ] Here is another example that tests if a project contains a docker file. If it does not include a docker file it reduces the priority of the recipe. \"RecommendationRules\": [ ... { \"Tests\": [ { \"Type\": \"FileExists\", \"Condition\": { \"FileName\": \"Dockerfile\" } } ], \"Effect\": { \"Fail\": { \"PriorityAdjustment\": -100, \"Include\": true } } }, ... ] A recipe is considered compatible if no rule ran an effect that set Include to false and if the priority is greater then 0. To simulate an \"or\" set of rules the starting priority in RecipePriority can be set to a negative value meaning it is not included by default. Then you can have a series of tests that adjust the priority to a positive amount. That way if any test rule passes it can adjust the priority to a positive number.","title":"Effect"},{"location":"docs/deployment-projects/recipe-file/#setting-categories","text":"The Categories property is an array of objects that define the categories for the settings. The AWS Toolkit for Visual Studio uses this array to build the list of categories in the UI for fast navigation to a group of settings. A category is defined with the following properties: Id - the unique id within the recipe for the category. DisplayName - the name of the category displayed to users. Order - the order in the toolkit for the category. Categories are display in sorted descending order. Here is an example of defining a custom category that you could use to categorize additional settings added as application resources. { \"Id\": \"AppResources\", \"DisplayName\": \"Application Resources\", \"Order\": 15 } To assign a setting to a category, set the setting's Category property of to the Id of a category. Only top level settings can be assigned a category. Any top level settings that are not assigned a category will be placed in the General category.","title":"Setting Categories"},{"location":"docs/deployment-projects/recipe-file/#option-settings","text":"The settings that are shown to users and allows users to customize the deployment in either the CLI or Visual Studio are defined in the OptionSettings array. Settings have the following properties. Id - the id of the setting. Once projects are deployed with the recipe, this id should not change because the id is saved into the CloudFormation stack's template. Name - the name of the setting shown to users. Description - the informational text shown to users for the setting. Type - the data type of the setting. DefaultValue - the default value for the setting. TypeHint - a hint to the deployment tooling what the meaning of the setting is. TypeHintData - additional information to pass into the type hint. AdvancedSetting - a boolean for whether this setting is an advanced use case. If true the setting might not be shown to users unless the request to see all settings. Updatable - a boolean that controls whether a setting can be modified during redeployment. It is recommended to set this to false for settings where deleting resources once they exist would make the application unavailable. AllowedValues - the list of possible values. ValueMapping - a mapping between values in the AllowedValues list to user friendly display names for each allowed value. ChildOptionSettings - if the Type property is set to Object this list contains a child option settings. DependsOn - a list of expressions to determine if this setting should be visible. Validators - a list of validators to run when values are set for the setting to ensure the value is valid. ParentSettingId - the id of a setting that represents the parent of this setting. For example a setting that allows picking EC2 subnets would set the ParentSettingId to the setting that defines the VPC to use for deployment. The type hint for the setting can use this field to filter the list of subnets that are valid for the selected VPC.","title":"Option Settings"},{"location":"docs/deployment-projects/recipe-file/#setting-data-types","text":"Settings can have the following data types: String Int Double Bool KeyValue List Object If the data type is set to Object the setting has child settings that are defined in the ChildOptionSettings array for the setting.","title":"Setting Data Types"},{"location":"docs/deployment-projects/recipe-file/#typehint","text":"Type hints are used to control the user experience in the CLI or Visual Studio. For example if the TypeHint property is set to ExistingECSCluster the deployment tool knows this String data type setting should be set to the name of an existing ECS cluster and presents the list of existing clusters to the user. Some type hints require additional configuration which can specified in the TypeHintData property. For example if a setting has a type hint of ExistingIAMRole the tool should only show roles that can be assumed by the target service. Here is a example of configuring the ServicePrincipal for the type hint to filter the list of roles to pick from. { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"ecs-tasks.amazonaws.com\" }, ... Here is the list of available type hints in the deployment tooling. Type Hint Type Hint Data Notes IAMRole ServicePrincipal - the service principal the role can be assumed by. Set at Object level that controls whether to create a new role or select an existing role. ExistingIAMRole ServicePrincipal - the service principal the role can be assumed by. Set at the String setting level for storing the existing IAM role arn. ECSCluster Set at the Object setting level that controls whether to create or select an existing ECS cluster. ExistingECSCluster Set at the String setting level for storing the existing ECS Cluster Name. ECSService ECSTaskSchedule EC2KeyPair Vpc Set at the Object level that controls whether to create a new VPC or select an existing VPC. ExistingVpc Set at the String setting level for storing the existing VPC ID. AppRunnerService VPCConnector Set at the Object level for creating or selecting an App Runner VPC Connector. ExistingVpcConnector Set at the String setting level for storing the existing VPC Connector id. BeanstalkRollingUpdates ExistingSubnets ParentSettingId should be set to a setting for the VPC. ExistingSecurityGroups ParentSettingId should be set to a setting for the VPC. ExistingBeanstalkApplication ExistingApplicationLoadBalancer InstanceType WindowsInstanceType S3BucketName AllowNoValue - determines whether to allow no value to be set. DynamoDBTableName AllowNoValue - determines whether to allow no value to be set. SQSQueueUrl AllowNoValue - determines whether to allow no value to be set. SNSTopicArn AllowNoValue - determines whether to allow no value to be set. FilePath Filter - the filter that appears in the file dialog box. DefaultExtension - the default extension used if the user specifies a file name without an extension. Title - the title of the file dialog box. CheckFileExists - if true the deployment tooling ensures the file exists. AllowEmpty - controls whether an empty value is allowed. DotnetBeanstalkPlatformArn DotnetWindowsBeanstalkPlatformArn DotnetPublishSelfContainedBuild Used internally to validate build configuration. DotnetPublishBuildConfiguration Used internally to validate build configuration. DotnetPublishAdditionalBuildArguments Used internally to validate build configuration. DockerExecutionDirectory Used internally to validate build configuration. DockerBuildArgs Used internally to validate build configuration.","title":"TypeHint"},{"location":"docs/deployment-projects/recipe-file/#dependson","text":"The DependsOn property is an array of conditions to determine if a setting should be visible based on the values for other setting(s). For example if a user selects the setting to create a new IAM role then the setting for the selecting an existing IAM role should not be displayed. Each item in the DependsOn array has the following properties. Id - the id of the setting compare. The id should be full id including all parent object id settings. The format is . . Operation - the operation to run. Allowed values are NotEmpty and Equals . If operation is not set then the default is Equals . Value - the value to compare when the operation is Equals . Here is an example for a setting used for storing an existing IAM role to use. The value is displayed if the setting ApplicationIAMRole.CreateNew is set false. { \"Id\": \"RoleArn\", \"Name\": \"Existing Role ARN\", \"Description\": \"The ARN of the existing role to use.\", \"Type\": \"String\", \"TypeHint\": \"ExistingIAMRole\", \"TypeHintData\": { \"ServicePrincipal\": \"tasks.apprunner.amazonaws.com\" }, \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"ApplicationIAMRole.CreateNew\", \"Value\": false } ], ... }","title":"DependsOn"},{"location":"docs/deployment-projects/recipe-file/#validators","text":"Validators allow telling the user when a setting has an invalid value before starting the deployment. Each setting can have a list of validators specified in the Validators array. Validators can do simple checks like making sure string values are of a certain format as well as make AWS service calls to make sure the value of an existing resource exists. Here is an example of a validator for a port setting that ensures the value is within the range 0 to 51200. ... { \"Id\": \"Port\", \"Name\": \"Port\", \"Category\": \"General\", \"Description\": \"The port the container is listening for requests on.\", \"Type\": \"Int\", \"DefaultValue\": 80, \"AdvancedSetting\": false, \"Updatable\": true, \"Validators\": [ { \"ValidatorType\": \"Range\", \"Configuration\": { \"Min\": 0, \"Max\": 51200 } } ] } ... The ValidatorType property determines the type of validator to run. The Configuration contains the data needed to evaluate the validator, in this case the min and max values. Each type of validator can have a different set of properties for the Configuration . Validator Type Description Configuration properties Range For numeric settings define the min and max values. Min - the min value. Max - the max value. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Regex For string settings define a regular expression that the value must match. Regex - the regular expression to match against the value of the setting. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. Required A value is required for the setting. ValidationFailedMessage - the error message shown if the validator fails. DirectoryExists For string settings representing a directory. Validates the directory exists. DockerBuildArgs Ensures the value is valid for being passed to the docker build command. DotnetPublishArgs Ensures the value is valid for being passed to the dotnet publish command. ExistingResource Using the AWS Cloud Control API GetResource , ensure that the AWS resource exists. ResourceType - the AWS resource type to search for. For example AWS::ECS::Cluster for an ECS cluster. FileExists For string settings representing a file path. Validates the file exists. ValidationFailedMessage - the error message shown if the validator fails. AllowEmptyString - boolean that if true allows empty values to be set. StringLength Validates the length of a string setting. MinLength - the min length for the string. MaxLength - the max length for the string. ValidationFailedMessage - the error message shown if the validator fails. InstanceType Validates the string value is a valid Linux EC2 instance type. WindowsInstanceType Validates the string value is a valid Windows EC2 instance type. SubnetsInVpc Validates the subnets are in the configured VPC. VpcId - the id of the setting that has the VPC configured for. ValidationFailedMessage - the error message shown if the validator fails. SecurityGroupsInVpc Validates the security group are in the configured VPC. VpcId - the id of the setting that has the VPC configured for. ValidationFailedMessage - the error message shown if the validator fails. Uri Validates the value is a well-formed URI string. ValidationFailedMessage - the error message shown if the validator fails. Comparison Compares this setting with another setting. SettingId - the setting to compare to. Operation - the comparison operation. Allowed values are GreaterThan . VPCSubnetsInDifferentAZs Validates that the selected VPC must have at least two subnets in two different Availability Zones ValidationFailedMessage - the error message shown if the validator fails.","title":"Validators"},{"location":"docs/docker/docker-generation/","text":"Dockerfile Generation IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used for deployment. The Dockerfile that deployment tools generates uses Docker's multistage build process. This allows efficient and smaller container images that only contain the bits that are required to run your application. For a sample web application which has following directory structure: \u2503MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln Build Build stage consists of copying the files from the host machine to the container, restoring the dependencies, and building the application. Deployment Tool uses .sln directory as build context and generates file paths relative to the .sln directory. FROM mcr.microsoft.com/dotnet/core/aspnet:6.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 443 WORKDIR /src COPY [\"MyWebApplication/MyWebApplication.csproj\", \"MyWebApplication/\"] COPY [\"MyClassLibrary/MyClassLibrary.csproj\", \"MyClassLibrary/\"] RUN dotnet restore \"MyWebApplication/MyWebApplication.csproj\" COPY . . WORKDIR \"/src/MyWebApplication\" RUN dotnet build \"MyWebApplication.csproj\" -c Release -o /app/build Publish Publish stage takes the build output and publishes the .NET application to /app/publish directory. FROM build AS publish RUN dotnet publish \"MyWebApplication.csproj\" -c Release -o /app/publish Final Final stage takes the publish output and copies it to the container which uses ASP.NET Core image as a base image. FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"MyWebApplication.dll\"]","title":"Dockerfile generation"},{"location":"docs/docker/docker-generation/#dockerfile-generation","text":"IF YOUR PROJECT DOES NOT CONTAIN A DOCKERFILE, THE DEPLOYMENT TOOL WILL ATTEMPT TO AUTOMATICALLY GENERATE IT, otherwise an existing Dockerfile will be used for deployment. The Dockerfile that deployment tools generates uses Docker's multistage build process. This allows efficient and smaller container images that only contain the bits that are required to run your application. For a sample web application which has following directory structure: \u2503MyWebApplication/ \u2523 MyClassLibrary/ \u2503 \u2523 Class1.cs \u2503 \u2517 MyClassLibrary.csproj \u2523 MyWebApplication/ \u2503 \u2523 Controllers/ \u2503 \u2503 \u2517 WeatherForecastController.cs \u2503 \u2523 appsettings.Development.json \u2503 \u2523 appsettings.json \u2503 \u2523 Dockerfile \u2503 \u2523 MyWebApplication.csproj \u2503 \u2523 Program.cs \u2503 \u2517 WeatherForecast.cs \u2517 MyWebApplication.sln","title":"Dockerfile Generation"},{"location":"docs/docker/docker-generation/#build","text":"Build stage consists of copying the files from the host machine to the container, restoring the dependencies, and building the application. Deployment Tool uses .sln directory as build context and generates file paths relative to the .sln directory. FROM mcr.microsoft.com/dotnet/core/aspnet:6.0 AS base WORKDIR /app EXPOSE 80 EXPOSE 443 WORKDIR /src COPY [\"MyWebApplication/MyWebApplication.csproj\", \"MyWebApplication/\"] COPY [\"MyClassLibrary/MyClassLibrary.csproj\", \"MyClassLibrary/\"] RUN dotnet restore \"MyWebApplication/MyWebApplication.csproj\" COPY . . WORKDIR \"/src/MyWebApplication\" RUN dotnet build \"MyWebApplication.csproj\" -c Release -o /app/build","title":"Build"},{"location":"docs/docker/docker-generation/#publish","text":"Publish stage takes the build output and publishes the .NET application to /app/publish directory. FROM build AS publish RUN dotnet publish \"MyWebApplication.csproj\" -c Release -o /app/publish","title":"Publish"},{"location":"docs/docker/docker-generation/#final","text":"Final stage takes the publish output and copies it to the container which uses ASP.NET Core image as a base image. FROM base AS final WORKDIR /app COPY --from=publish /app/publish . ENTRYPOINT [\"dotnet\", \"MyWebApplication.dll\"]","title":"Final"},{"location":"docs/docker/publish-image/","text":"Pushing a Docker image to Amazon ECR repository If your application contains an existing Dockerfile, you can build and push your container images to an Amazon Elastic Container Registry (Amazon ECR) repository using \"Push Container Images to Amazon Elastic Container Registry\" deployment option. To learn more about Amazon ECR, including required IAM permissions for pushing an image, see Amazon ECR product page .","title":"Publishing a Docker image"},{"location":"docs/docker/publish-image/#pushing-a-docker-image-to-amazon-ecr-repository","text":"If your application contains an existing Dockerfile, you can build and push your container images to an Amazon Elastic Container Registry (Amazon ECR) repository using \"Push Container Images to Amazon Elastic Container Registry\" deployment option. To learn more about Amazon ECR, including required IAM permissions for pushing an image, see Amazon ECR product page .","title":"Pushing a Docker image to Amazon ECR repository"},{"location":"docs/getting-started/custom-workspace/","text":"The default workspace used by AWS.Deploy.Tools is $USERPROFILE/.aws-dotnet-deploy on Windows and $USER/.aws-dotnet-deploy on Unix based OS. This workspace is used to create the CDK project and any other temporary files used by the tool. You can override the default workspace by the setting the AWS_DOTNET_DEPLOYTOOL_WORKSPACE environment variable. It must satisfy the following constraints: It must point to a valid directory that exists on the disk. The directory path must not have any whitespace characters in it. Setting up a custom workspace is optional for most users. However, on Windows OS, if the $USERPROFILE path contains a whitespace character then the deployment will fail. In that case, users are required to set up a custom workspace that satisfies the above constraints.","title":"Set up custom workspace"},{"location":"docs/getting-started/installation/","text":"Installing the deployment tool The following instructions show you how to install, update, and uninstall the deployment tool. Install To install the deployment tool, use the dotnet tool install command: dotnet tool install -g aws.deploy.tools Update To update to the latest version of the deployment tool, use the dotnet tool update command. dotnet tool update -g aws.deploy.tools Note The deployment tool was initially in a NuGet package called \"aws.deploy.cli\". If you have this older version of the tool, you'll see a deprecation notice and the version will be 0.40.18 or earlier. Uninstall the older version of the tool and install a new one. Uninstall To uninstall it, simply type: dotnet tool uninstall -g aws.deploy.tools Help Once you install the tool, you can view the list of available commands by typing: dotnet aws --help To get help about individual commands like deploy or delete-deployment you can use the --help switch with the commands. For example to get help for the deploy command type: dotnet aws deploy --help","title":"How to install"},{"location":"docs/getting-started/installation/#installing-the-deployment-tool","text":"The following instructions show you how to install, update, and uninstall the deployment tool.","title":"Installing the deployment tool"},{"location":"docs/getting-started/installation/#install","text":"To install the deployment tool, use the dotnet tool install command: dotnet tool install -g aws.deploy.tools","title":"Install"},{"location":"docs/getting-started/installation/#update","text":"To update to the latest version of the deployment tool, use the dotnet tool update command. dotnet tool update -g aws.deploy.tools Note The deployment tool was initially in a NuGet package called \"aws.deploy.cli\". If you have this older version of the tool, you'll see a deprecation notice and the version will be 0.40.18 or earlier. Uninstall the older version of the tool and install a new one.","title":"Update"},{"location":"docs/getting-started/installation/#uninstall","text":"To uninstall it, simply type: dotnet tool uninstall -g aws.deploy.tools","title":"Uninstall"},{"location":"docs/getting-started/installation/#help","text":"Once you install the tool, you can view the list of available commands by typing: dotnet aws --help To get help about individual commands like deploy or delete-deployment you can use the --help switch with the commands. For example to get help for the deploy command type: dotnet aws deploy --help","title":"Help"},{"location":"docs/getting-started/pre-requisites/","text":"Setting up your environment To run the AWS Deploy Tool, you need the following pre-requisites set up in your environment: AWS Account An AWS account with a local credential profile configured in the shared AWS config and credentials files. For information on setting up a profile, see our SDK Reference Guide . The local credential profile can be configured by a variety of tools. For example, the credential profile can be configured with the AWS Toolkit for Visual Studio or the AWS CLI , among others. Note: You need to make sure to add the appropriate AWS permissions to your credentials\u2019 profile / assumed role. See Setting up Credentials .NET Core 3.1 or later .NET CLI - the deployment tool can be used from the .NET command-line interface (CLI) - a cross-platform toolchain for developing, building, running, and publishing .NET applications. The .NET CLI is included with the .NET SDK . For information about how to install or update .NET, see https://dotnet.microsoft.com/ . The application you are deploying must be built from .NET Core 3.1 or later (for example, .NET Core 3.1, .NET 5.0, .NET 6.0). To see what version you have, run the following on the command prompt or in a terminal: dotnet --version Node.js The deployment tool requires the AWS Cloud Development Kit (CDK) , and the AWS CDK requires Node.js . AWS CDK requires Node.js, versions 14.x, 16.x, 18.x (or later) - we recommend installing the latest LTS version. To install Node.js, go to Node.js downloads To see which version of Node.js you have installed, run the following command at the command prompt or in a terminal: node --version Note: If the AWS CDK isn't installed on your machine or if the AWS CDK that's installed is earlier than the required minimum version (2.13.0), the deployment tool will install a temporary and \"private\" copy of the CDK that will be used only by the tool, leaving the global configuration of your machine untouched. If instead you want to install the AWS CDK, see Install the AWS CDK in the AWS Cloud Development Kit (CDK) Developer Guide Docker (Optional) Docker - required when deploying to a container based service like Amazon Elastic Container Service (Amazon ECS) or AWS App Runner. To install Docker, go to https://docs.docker.com/engine/install/ . ZIP CLI (Linux and macOS) Mac / Linux only. Used when creating zip packages for deployment bundles. The zip cli is used to maintain Linux file permissions.","title":"Pre-requisites"},{"location":"docs/getting-started/pre-requisites/#setting-up-your-environment","text":"To run the AWS Deploy Tool, you need the following pre-requisites set up in your environment:","title":"Setting up your environment"},{"location":"docs/getting-started/pre-requisites/#aws-account","text":"An AWS account with a local credential profile configured in the shared AWS config and credentials files. For information on setting up a profile, see our SDK Reference Guide . The local credential profile can be configured by a variety of tools. For example, the credential profile can be configured with the AWS Toolkit for Visual Studio or the AWS CLI , among others. Note: You need to make sure to add the appropriate AWS permissions to your credentials\u2019 profile / assumed role. See Setting up Credentials","title":"AWS Account"},{"location":"docs/getting-started/pre-requisites/#net-core-31-or-later","text":".NET CLI - the deployment tool can be used from the .NET command-line interface (CLI) - a cross-platform toolchain for developing, building, running, and publishing .NET applications. The .NET CLI is included with the .NET SDK . For information about how to install or update .NET, see https://dotnet.microsoft.com/ . The application you are deploying must be built from .NET Core 3.1 or later (for example, .NET Core 3.1, .NET 5.0, .NET 6.0). To see what version you have, run the following on the command prompt or in a terminal: dotnet --version","title":".NET Core 3.1 or later"},{"location":"docs/getting-started/pre-requisites/#nodejs","text":"The deployment tool requires the AWS Cloud Development Kit (CDK) , and the AWS CDK requires Node.js . AWS CDK requires Node.js, versions 14.x, 16.x, 18.x (or later) - we recommend installing the latest LTS version. To install Node.js, go to Node.js downloads To see which version of Node.js you have installed, run the following command at the command prompt or in a terminal: node --version Note: If the AWS CDK isn't installed on your machine or if the AWS CDK that's installed is earlier than the required minimum version (2.13.0), the deployment tool will install a temporary and \"private\" copy of the CDK that will be used only by the tool, leaving the global configuration of your machine untouched. If instead you want to install the AWS CDK, see Install the AWS CDK in the AWS Cloud Development Kit (CDK) Developer Guide","title":"Node.js"},{"location":"docs/getting-started/pre-requisites/#docker-optional","text":"Docker - required when deploying to a container based service like Amazon Elastic Container Service (Amazon ECS) or AWS App Runner. To install Docker, go to https://docs.docker.com/engine/install/ .","title":"Docker (Optional)"},{"location":"docs/getting-started/pre-requisites/#zip-cli-linux-and-macos","text":"Mac / Linux only. Used when creating zip packages for deployment bundles. The zip cli is used to maintain Linux file permissions.","title":"ZIP CLI (Linux and macOS)"},{"location":"docs/getting-started/run-tool/","text":"Deploying a sample application This article teaches you how to deploy a simple \u201cHello World!\" web application to AWS. Install the tool and its pre-requisites before running the steps below. The command for the deployment tool can be expressed in one of two forms. Either form might be used for command examples. dotnet aws ... dotnet-aws ... Step 1: Create ASP.NET Web application dotnet new web -n HelloWorld -f net6.0 Step 2: cd to the project cd HelloWorld Step 3: Deploy to AWS dotnet aws deploy --profile default --region us-east-1","title":"Deploy \"Hello World\""},{"location":"docs/getting-started/run-tool/#deploying-a-sample-application","text":"This article teaches you how to deploy a simple \u201cHello World!\" web application to AWS. Install the tool and its pre-requisites before running the steps below. The command for the deployment tool can be expressed in one of two forms. Either form might be used for command examples. dotnet aws ... dotnet-aws ...","title":"Deploying a sample application"},{"location":"docs/getting-started/run-tool/#step-1-create-aspnet-web-application","text":"dotnet new web -n HelloWorld -f net6.0","title":"Step 1: Create ASP.NET Web application"},{"location":"docs/getting-started/run-tool/#step-2-cd-to-the-project","text":"cd HelloWorld","title":"Step 2: cd to the project"},{"location":"docs/getting-started/run-tool/#step-3-deploy-to-aws","text":"dotnet aws deploy --profile default --region us-east-1","title":"Step 3: Deploy to AWS"},{"location":"docs/getting-started/setup-creds/","text":"Setting up credentials AWS.Deploy.Tools, internally uses a variety of different tools and services to host your .NET application on AWS. To run the AWS Deploy Tool, you must configure a credential profile that provides access to the AWS account you wish to deploy to. Your credentials must have permissions for certain services, depending on the tasks that you're trying to perform. Recommended policies The following are some examples of the typical permissions that are required. Note: Additional permissions might be required, depending on the type of application you're deploying and the services it uses. Command Task Recommended AWS Managed Policies deploy Deploying to Amazon ECS AWSCloudFormationFullAccess, AmazonECS_FullAccess, AmazonEC2ContainerRegistryFullAccess, IAMFullAccess deploy Deploying to AWS App Runner AWSCloudFormationFullAccess, AWSAppRunnerFullAccess, AmazonEC2ContainerRegistryFullAccess, IAMFullAccess deploy Deploying to Elastic Beanstalk (deploy) AWSCloudFormationFullAccess, AdministratorAccess-AWSElasticBeanstalk', AmazonS3FullAccess ( required to upload the application bundle ), IAMFullAccess deploy Hosting WebAssembly Blazor App in S3 & CloudFront AmazonS3FullAccess, CloudFrontFullAccess, IAMFullAccess, AWSLambda_FullAccess ( required to copy from CDKBootstrap bucket to S3 bucket ) list-deployments List CF stacks AWSCloudFormationReadOnlyAccess delete-deployment Delete a CF stack AWSCloudFormationFullAccess + permissions for resources being deleted Note: If you are creating IAM roles, you need IAMFullAccess otherwise IAMReadOnlyAccess. Note that the first time the CDK bootstrap stack is created it will need IAMFullAccess. Note: If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. The exact wording for an insufficient permissions related errors may differ. Specifying profile and region In your shared AWS config and credentials files, if the [default] profile exists, the deployment tool uses that profile by default. You can change this behavior by specifying a profile for the tool to use, either system-wide or in a particular context. ... locally The simplest way to specify region and profile is to provide them as parameters to the tool. dotnet aws deploy --profile customProfile --region us-west-2 . For additional information about command parameters, see Commands section. Note If you provide only the --profile argument, the AWS Region isn't read from the profile that you specify. Instead, the tool reads the Region from the [default] profile if one exists, or asks for the desired profile interactively. ... system-wide To specify a system-wide profile and region, define the AWS_PROFILE and AWS_REGION environment variables globally, as appropriate for your operating system. Be sure to reopen command prompts or terminals as necessary. Warning If you set the AWS_PROFILE environment variable globally for your system, other SDKs, CLIs, and tools will also use that profile. If this behavior is unacceptable, specify a profile for a particular context instead. Additional Resources For information on AWS credentials and access management, see Credentials and Access For information on configuration file settings, see Config and Auth Settings Reference For information on how to create customer managed IAM policies, see Tutorial on Managed Policies For information on how to troubleshoot IAM policies, see AWS IAM User Guide For information on AWS Single Sign On (AWS SSO), visit the .NET SDK Reference Guide . For information on how to provide AWS credentials in AWS Toolkit for Visual Studio, see AWS Toolkit for Visual Studio User Guide .","title":"Set up Credentials"},{"location":"docs/getting-started/setup-creds/#setting-up-credentials","text":"AWS.Deploy.Tools, internally uses a variety of different tools and services to host your .NET application on AWS. To run the AWS Deploy Tool, you must configure a credential profile that provides access to the AWS account you wish to deploy to. Your credentials must have permissions for certain services, depending on the tasks that you're trying to perform.","title":"Setting up credentials"},{"location":"docs/getting-started/setup-creds/#recommended-policies","text":"The following are some examples of the typical permissions that are required. Note: Additional permissions might be required, depending on the type of application you're deploying and the services it uses. Command Task Recommended AWS Managed Policies deploy Deploying to Amazon ECS AWSCloudFormationFullAccess, AmazonECS_FullAccess, AmazonEC2ContainerRegistryFullAccess, IAMFullAccess deploy Deploying to AWS App Runner AWSCloudFormationFullAccess, AWSAppRunnerFullAccess, AmazonEC2ContainerRegistryFullAccess, IAMFullAccess deploy Deploying to Elastic Beanstalk (deploy) AWSCloudFormationFullAccess, AdministratorAccess-AWSElasticBeanstalk', AmazonS3FullAccess ( required to upload the application bundle ), IAMFullAccess deploy Hosting WebAssembly Blazor App in S3 & CloudFront AmazonS3FullAccess, CloudFrontFullAccess, IAMFullAccess, AWSLambda_FullAccess ( required to copy from CDKBootstrap bucket to S3 bucket ) list-deployments List CF stacks AWSCloudFormationReadOnlyAccess delete-deployment Delete a CF stack AWSCloudFormationFullAccess + permissions for resources being deleted Note: If you are creating IAM roles, you need IAMFullAccess otherwise IAMReadOnlyAccess. Note that the first time the CDK bootstrap stack is created it will need IAMFullAccess. Note: If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. The exact wording for an insufficient permissions related errors may differ.","title":"Recommended policies"},{"location":"docs/getting-started/setup-creds/#specifying-profile-and-region","text":"In your shared AWS config and credentials files, if the [default] profile exists, the deployment tool uses that profile by default. You can change this behavior by specifying a profile for the tool to use, either system-wide or in a particular context.","title":"Specifying profile and region"},{"location":"docs/getting-started/setup-creds/#locally","text":"The simplest way to specify region and profile is to provide them as parameters to the tool. dotnet aws deploy --profile customProfile --region us-west-2 . For additional information about command parameters, see Commands section. Note If you provide only the --profile argument, the AWS Region isn't read from the profile that you specify. Instead, the tool reads the Region from the [default] profile if one exists, or asks for the desired profile interactively.","title":"... locally"},{"location":"docs/getting-started/setup-creds/#system-wide","text":"To specify a system-wide profile and region, define the AWS_PROFILE and AWS_REGION environment variables globally, as appropriate for your operating system. Be sure to reopen command prompts or terminals as necessary. Warning If you set the AWS_PROFILE environment variable globally for your system, other SDKs, CLIs, and tools will also use that profile. If this behavior is unacceptable, specify a profile for a particular context instead.","title":"... system-wide"},{"location":"docs/getting-started/setup-creds/#additional-resources","text":"For information on AWS credentials and access management, see Credentials and Access For information on configuration file settings, see Config and Auth Settings Reference For information on how to create customer managed IAM policies, see Tutorial on Managed Policies For information on how to troubleshoot IAM policies, see AWS IAM User Guide For information on AWS Single Sign On (AWS SSO), visit the .NET SDK Reference Guide . For information on how to provide AWS credentials in AWS Toolkit for Visual Studio, see AWS Toolkit for Visual Studio User Guide .","title":"Additional Resources"},{"location":"troubleshooting-guide/","text":"General Issues This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues you might encounter during the deployment process. Invalid project path provided Why is this happening : The CLI deployment command takes in an optional --project-path option. For example: dotnet aws deploy --project-path <PATH> The deployment process would fail if an invalid --project-path is provided. Resolution : The --project-path can be absolute or relative to the current working directory and must be one of the following: A file path pointing to a *.csproj or *.fsproj file. A directory path that contains a *.csproj or *.fsproj file. If a --project-path option is not provided, then AWS.Deploy.Tools will look for a *.csproj or *.fsproj file in the current working directory. Failed to find compatible deployment recommendations Why is this happening : Behind the scenes, AWS.Deploy.Tools uses a recipe configuration file to provide an opinionated deployment experience. See here to learn more about recipes. Recipe configurations target different AWS services and there may be incompatibilities between the chosen recipe and your .NET application. Another reason why there are no recommendations generated is if your application's .csproj file is using a variable for the TargetFramework property. For example: <Project Sdk=\"Microsoft.NET.Sdk.Web\"> <PropertyGroup> <TargetFrameworkVersion>net5.0</TargetFrameworkVersion> <TargetFramework>$(TargetFrameworkVersion)</TargetFramework> </PropertyGroup> </Project> No recommendations will be generated for the above .csproj file. This is a bug which we will address : GitHub issue . Meanwhile, please provide explicit values for the TargetFramework property. Resolution : If you think that your project is not correctly recognized by our tool and no recommendations are generated, then file a GitHub issue describing your project and also providing relevant details about your .csproj or .fsproj file. This will help us understand and narrow down the gaps in our recommendation engine and customer use cases. Deployment failures related to JSON configuration file Why is this happening : AWS.Deploy.Tools allows for prompt-less deployments using a JSON configuration file. This workflow can easily be plugged into your CI/CD pipeline for automated deployments. If a deployment failure occurs while using a configuration file, It is possible that the configuration file has the wrong definition or the wrong format. Resolution : Kindly ensure that the JSON configuration file has the correct JSON syntax. See here for an example of a valid JSON configuration file. Insufficient IAM Permissions Why is this happening : Access to AWS is governed by IAM policies. They are a group of permissions which determine whether the request to an AWS resource/service is allowed or denied. AWS.Deploy.Tools, internally uses a variety of different services to host your .NET application on AWS. If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. Note: Exact wording for an insufficient permissions related errors may differ from the above Resolution : You can refer to the official AWS documentation on IAM policies: See here for a tutorial on how to create customer managed IAM policies. See here for troubleshooting IAM policies. Deployment failure due to whitespace character in USERPROFILE path Why is this happening : This happens due to a know issue with the AWS Cloud Development Kit (CDK). The CDK is used by AWS.Deploy.Tools under the covers and it cannot cannot access the $TEMP directory inside the $USERPROFILE path if it contains a whitespace character. Resolution : See here for guidance on setting a custom workspace that will be used by AWS.Deploy.Tools. AWS CDK Bootstrap related Deployment Failure A common error that is displayed for CDK Bootstrap related deployment failures is the following: The AWS CDK Bootstrap, which is the process of provisioning initial resources for the deployment environment, has failed. Please review the output above for additional details [and check out our troubleshooting guide for the most common failure reasons]. You can learn more about CDK bootstrapping at https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html. The AWS Deploy Tool for .NET uses AWS CDK to create the AWS infrastructure needed to deploy your application. The AWS CDK is a framework for defining cloud infrastructure in code and provisioning it through AWS CloudFormation. Deploying AWS CDK apps into an AWS environment (a combination of an AWS account and region) requires that you provision resources the AWS CDK needs to perform the deployment. These resources include an Amazon S3 bucket for storing files and IAM roles that grant permissions needed to perform deployments. The process of provisioning these initial resources is called bootstrapping . The required resources are defined in a AWS CloudFormation stack, called the bootstrap stack, which is usually named CDKToolkit . Like any AWS CloudFormation stack, it appears in the AWS CloudFormation console once it has been deployed. There could be several reasons why you are experiencing this issue. However, the most common ones are related to Insufficient IAM Permissions and an Existing CDK Staging Bucket . Insufficient IAM Permission : CDKBoostrap failed because your profile does not have sufficient permissions to create the boostrap stack. Check the log - in this case, you should see an error that looks something like this: LookupRole API: iam:GetRole User: arn:aws:iam::123456789101:user/user is not authorized to perform: iam:GetRole on resource Resolution : Add missing IAM permissions to your profile. See our documentation for recommended IAM policies for each deployment type. Existing CDKToolkit S3 bucket : In rare cases, it is possible for the CDK Boostrap process to not clean the resources properly after the failed deployment. This causes the next deployment to fail as well, because the S3 bucket already exists. The error could look something like: StagingBucket cdk-hnb659fds-assets-123456789101-us-west-2 already exists Resolution : Open the AWS Console, go to S3 service, and manually delete the 'CDKToolkit' S3 bucket. Once the bucket is deleted, go ahead and deploy your application.","title":"General Issues"},{"location":"troubleshooting-guide/#general-issues","text":"This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues you might encounter during the deployment process.","title":"General Issues"},{"location":"troubleshooting-guide/#invalid-project-path-provided","text":"Why is this happening : The CLI deployment command takes in an optional --project-path option. For example: dotnet aws deploy --project-path <PATH> The deployment process would fail if an invalid --project-path is provided. Resolution : The --project-path can be absolute or relative to the current working directory and must be one of the following: A file path pointing to a *.csproj or *.fsproj file. A directory path that contains a *.csproj or *.fsproj file. If a --project-path option is not provided, then AWS.Deploy.Tools will look for a *.csproj or *.fsproj file in the current working directory.","title":"Invalid project path provided"},{"location":"troubleshooting-guide/#failed-to-find-compatible-deployment-recommendations","text":"Why is this happening : Behind the scenes, AWS.Deploy.Tools uses a recipe configuration file to provide an opinionated deployment experience. See here to learn more about recipes. Recipe configurations target different AWS services and there may be incompatibilities between the chosen recipe and your .NET application. Another reason why there are no recommendations generated is if your application's .csproj file is using a variable for the TargetFramework property. For example: <Project Sdk=\"Microsoft.NET.Sdk.Web\"> <PropertyGroup> <TargetFrameworkVersion>net5.0</TargetFrameworkVersion> <TargetFramework>$(TargetFrameworkVersion)</TargetFramework> </PropertyGroup> </Project> No recommendations will be generated for the above .csproj file. This is a bug which we will address : GitHub issue . Meanwhile, please provide explicit values for the TargetFramework property. Resolution : If you think that your project is not correctly recognized by our tool and no recommendations are generated, then file a GitHub issue describing your project and also providing relevant details about your .csproj or .fsproj file. This will help us understand and narrow down the gaps in our recommendation engine and customer use cases.","title":"Failed to find compatible deployment recommendations"},{"location":"troubleshooting-guide/#deployment-failures-related-to-json-configuration-file","text":"Why is this happening : AWS.Deploy.Tools allows for prompt-less deployments using a JSON configuration file. This workflow can easily be plugged into your CI/CD pipeline for automated deployments. If a deployment failure occurs while using a configuration file, It is possible that the configuration file has the wrong definition or the wrong format. Resolution : Kindly ensure that the JSON configuration file has the correct JSON syntax. See here for an example of a valid JSON configuration file.","title":"Deployment failures related to JSON configuration file"},{"location":"troubleshooting-guide/#insufficient-iam-permissions","text":"Why is this happening : Access to AWS is governed by IAM policies. They are a group of permissions which determine whether the request to an AWS resource/service is allowed or denied. AWS.Deploy.Tools, internally uses a variety of different services to host your .NET application on AWS. If you encounter an error saying user is not authorized to perform action because no identity based policies allow it , that means you need to add the corresponding permission to the IAM policy that is used by the current IAM role/user. Note: Exact wording for an insufficient permissions related errors may differ from the above Resolution : You can refer to the official AWS documentation on IAM policies: See here for a tutorial on how to create customer managed IAM policies. See here for troubleshooting IAM policies.","title":"Insufficient IAM Permissions"},{"location":"troubleshooting-guide/#deployment-failure-due-to-whitespace-character-in-userprofile-path","text":"Why is this happening : This happens due to a know issue with the AWS Cloud Development Kit (CDK). The CDK is used by AWS.Deploy.Tools under the covers and it cannot cannot access the $TEMP directory inside the $USERPROFILE path if it contains a whitespace character. Resolution : See here for guidance on setting a custom workspace that will be used by AWS.Deploy.Tools.","title":"Deployment failure due to whitespace character in USERPROFILE path"},{"location":"troubleshooting-guide/#aws-cdk-bootstrap-related-deployment-failure","text":"A common error that is displayed for CDK Bootstrap related deployment failures is the following: The AWS CDK Bootstrap, which is the process of provisioning initial resources for the deployment environment, has failed. Please review the output above for additional details [and check out our troubleshooting guide for the most common failure reasons]. You can learn more about CDK bootstrapping at https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html. The AWS Deploy Tool for .NET uses AWS CDK to create the AWS infrastructure needed to deploy your application. The AWS CDK is a framework for defining cloud infrastructure in code and provisioning it through AWS CloudFormation. Deploying AWS CDK apps into an AWS environment (a combination of an AWS account and region) requires that you provision resources the AWS CDK needs to perform the deployment. These resources include an Amazon S3 bucket for storing files and IAM roles that grant permissions needed to perform deployments. The process of provisioning these initial resources is called bootstrapping . The required resources are defined in a AWS CloudFormation stack, called the bootstrap stack, which is usually named CDKToolkit . Like any AWS CloudFormation stack, it appears in the AWS CloudFormation console once it has been deployed. There could be several reasons why you are experiencing this issue. However, the most common ones are related to Insufficient IAM Permissions and an Existing CDK Staging Bucket . Insufficient IAM Permission : CDKBoostrap failed because your profile does not have sufficient permissions to create the boostrap stack. Check the log - in this case, you should see an error that looks something like this: LookupRole API: iam:GetRole User: arn:aws:iam::123456789101:user/user is not authorized to perform: iam:GetRole on resource Resolution : Add missing IAM permissions to your profile. See our documentation for recommended IAM policies for each deployment type. Existing CDKToolkit S3 bucket : In rare cases, it is possible for the CDK Boostrap process to not clean the resources properly after the failed deployment. This causes the next deployment to fail as well, because the S3 bucket already exists. The error could look something like: StagingBucket cdk-hnb659fds-assets-123456789101-us-west-2 already exists Resolution : Open the AWS Console, go to S3 service, and manually delete the 'CDKToolkit' S3 bucket. Once the bucket is deleted, go ahead and deploy your application.","title":"AWS CDK Bootstrap related Deployment Failure"},{"location":"troubleshooting-guide/docker-issues/","text":"Docker Issues This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to Docker. Docker not running in Linux mode Why is this happening : If you are on a Windows operating system, it is likely that you are running Docker in Windows container mode. AWS.Deploy.Tools requires Docker to be running in Linux container mode. Resolution : See here to switch between Windows and Linux containers. Failed to build Docker Image There are multiple reasons your deployment may fail during the Docker build step. Invalid Dockerfile Why is this happening : If there is a syntax error or invalid argument in your Dockerfile, the Docker build command may fail with an error message like this: failed to solve with frontend dockerfile.v0: failed to create LLB definition: <additional error message> Resolution : Correct any syntax errors or invalid arguments in your Dockerfile. Consult Docker's Dockerfile reference for the expected syntax for each instruction. Invalid Docker execution directory Why is this happening : The Docker execution directory is the working directory for the Docker build command . All relative paths in the Dockerfile are resolved from this directory. By default, the execution directory is set to your project's solution directory. However it is possible that the Dockerfile is referencing projects outside of your solution directory, which may result in an error message like this: failed to compute cache key: \"/Path/To/A/Dependency.csproj\" not found: not found Resolution : AWS.Deploy.Tools allows you to specify an alternative Docker execution directory. Try setting an execution directory that can correctly evaluate all relative paths in the Dockerfile. If you are using the CLI version of AWS.Deploy.Tools, set the \"Docker Execution Directory\" under \"Advanced Settings.\" If you are using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio, set the \"Docker Execution Directory\" under the \"Project Build\" settings. Missing project dependencies Why is this happening : The Docker build command may fail during the RUN dotnet build instruction if all of your project dependencies are not specified in the Dockerfile. Resolution : Ensure all dependencies from your project and solution files are included in your Dockerfile. A good starting point is to inspect the solution file and add the relevant projects to the Dockerfile. If a custom Dockerfile is not initally provided, AWS.Deploy.Tools will generate one if you select a container-based deployment. The generated Dockerfile will include the projects currently defined in your solution file. This Dockerfile is persisted on disk. If you add a new dependency to the solution file in the future, you must manually add a new entry for it in the persisted Dockerfile. Failed to restore package references Why is this happening : The Docker build command may fail during the RUN dotnet restore instruction if the container does not have connectivity to the NuGet. You may see an error message like: Unable to load the service index for source https://api.nuget.org/v3/index.json or Failed to download package <package name> from https://api.nuget.org/ Resolution : Your container may be unable to access the internet or NuGet for a variety of network-related reasons. If you are using Docker Desktop, consult the Docker troubleshooting guide and documentation . If your container is able to access the internet but the package restore is failing because you are using a private NuGet feed, you may need to configure credentials for the private feed within the Dockerfile. Failed to push Docker Image Why is this happening : AWS.Deploy.Tools builds the Docker image and pushes it to Amazon Elastic Container Registry (Amazon ECR). If you are missing the required AWS Identity and Access Management (IAM) permissions to perform actions against ECR repositories, the deployment may fail the following error message: Failed to push Docker Image Resolution : See here for guidance on how to set IAM policy statements to allow actions on Amazon ECR repositories. Failed to generate a Dockerfile Why is this happening You may see this if your project has project references (.csproj, .vbproj) that are located in a higher folder than the solution file (.sln) that AWS.Deploy.Tools is using to generate a Dockerfile. In this case AWS.Deploy.Tools will not generate a Dockerfile to avoid a large build context that can result in long builds. Resolution : If you would still like to deploy to an AWS service that requires Docker , you must create your own Dockerfile and set an appropriate \"Docker Execution Directory\" in the deployment options. Alternatively you may choose another deployment target that does not require Docker, such as AWS Elastic Beanstalk.","title":"Docker Issues"},{"location":"troubleshooting-guide/docker-issues/#docker-issues","text":"This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to Docker.","title":"Docker  Issues"},{"location":"troubleshooting-guide/docker-issues/#docker-not-running-in-linux-mode","text":"Why is this happening : If you are on a Windows operating system, it is likely that you are running Docker in Windows container mode. AWS.Deploy.Tools requires Docker to be running in Linux container mode. Resolution : See here to switch between Windows and Linux containers.","title":"Docker not running in Linux mode"},{"location":"troubleshooting-guide/docker-issues/#failed-to-build-docker-image","text":"There are multiple reasons your deployment may fail during the Docker build step.","title":"Failed to build Docker Image"},{"location":"troubleshooting-guide/docker-issues/#invalid-dockerfile","text":"Why is this happening : If there is a syntax error or invalid argument in your Dockerfile, the Docker build command may fail with an error message like this: failed to solve with frontend dockerfile.v0: failed to create LLB definition: <additional error message> Resolution : Correct any syntax errors or invalid arguments in your Dockerfile. Consult Docker's Dockerfile reference for the expected syntax for each instruction.","title":"Invalid Dockerfile"},{"location":"troubleshooting-guide/docker-issues/#invalid-docker-execution-directory","text":"Why is this happening : The Docker execution directory is the working directory for the Docker build command . All relative paths in the Dockerfile are resolved from this directory. By default, the execution directory is set to your project's solution directory. However it is possible that the Dockerfile is referencing projects outside of your solution directory, which may result in an error message like this: failed to compute cache key: \"/Path/To/A/Dependency.csproj\" not found: not found Resolution : AWS.Deploy.Tools allows you to specify an alternative Docker execution directory. Try setting an execution directory that can correctly evaluate all relative paths in the Dockerfile. If you are using the CLI version of AWS.Deploy.Tools, set the \"Docker Execution Directory\" under \"Advanced Settings.\" If you are using the \"Publish to AWS\" feature in the AWS Toolkit for Visual Studio, set the \"Docker Execution Directory\" under the \"Project Build\" settings.","title":"Invalid Docker execution directory"},{"location":"troubleshooting-guide/docker-issues/#missing-project-dependencies","text":"Why is this happening : The Docker build command may fail during the RUN dotnet build instruction if all of your project dependencies are not specified in the Dockerfile. Resolution : Ensure all dependencies from your project and solution files are included in your Dockerfile. A good starting point is to inspect the solution file and add the relevant projects to the Dockerfile. If a custom Dockerfile is not initally provided, AWS.Deploy.Tools will generate one if you select a container-based deployment. The generated Dockerfile will include the projects currently defined in your solution file. This Dockerfile is persisted on disk. If you add a new dependency to the solution file in the future, you must manually add a new entry for it in the persisted Dockerfile.","title":"Missing project dependencies"},{"location":"troubleshooting-guide/docker-issues/#failed-to-restore-package-references","text":"Why is this happening : The Docker build command may fail during the RUN dotnet restore instruction if the container does not have connectivity to the NuGet. You may see an error message like: Unable to load the service index for source https://api.nuget.org/v3/index.json or Failed to download package <package name> from https://api.nuget.org/ Resolution : Your container may be unable to access the internet or NuGet for a variety of network-related reasons. If you are using Docker Desktop, consult the Docker troubleshooting guide and documentation . If your container is able to access the internet but the package restore is failing because you are using a private NuGet feed, you may need to configure credentials for the private feed within the Dockerfile.","title":"Failed to restore package references"},{"location":"troubleshooting-guide/docker-issues/#failed-to-push-docker-image","text":"Why is this happening : AWS.Deploy.Tools builds the Docker image and pushes it to Amazon Elastic Container Registry (Amazon ECR). If you are missing the required AWS Identity and Access Management (IAM) permissions to perform actions against ECR repositories, the deployment may fail the following error message: Failed to push Docker Image Resolution : See here for guidance on how to set IAM policy statements to allow actions on Amazon ECR repositories.","title":"Failed to push Docker Image"},{"location":"troubleshooting-guide/docker-issues/#failed-to-generate-a-dockerfile","text":"Why is this happening You may see this if your project has project references (.csproj, .vbproj) that are located in a higher folder than the solution file (.sln) that AWS.Deploy.Tools is using to generate a Dockerfile. In this case AWS.Deploy.Tools will not generate a Dockerfile to avoid a large build context that can result in long builds. Resolution : If you would still like to deploy to an AWS service that requires Docker , you must create your own Dockerfile and set an appropriate \"Docker Execution Directory\" in the deployment options. Alternatively you may choose another deployment target that does not require Docker, such as AWS Elastic Beanstalk.","title":"Failed to generate a Dockerfile"},{"location":"troubleshooting-guide/missing-dependencies/","text":"Missing Dependencies This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to missing external dependencies of AWS.Deploy.Tools Node.js not installed Why is this happening : AWS.Deploy.Tools relies on AWS Cloud Development Kit (CDK) to provision resources for your cloud application. AWS CDK requires Node.js to be installed in your machine. See the CDK's FAQs for more information about how it uses Node.js. Minimum required Node.js version >= 14.17.0 Resolution : See here to install Node.js on your system. Docker not installed Why is this happening : AWS.Deploy.Tool requires Docker to be installed in order to perform containerized deployments. Resolution : See here to install Docker for your operating system. Zip utility not installed Why is this happening : Non-container based deployments types (such as deployments to AWS Elastic Beanstalk) create a zip file of the artifacts produced by the dotnet publish command. The zip command line utility is not installed by default on some Linux distributions. If you are deploying using a non-container based option, you may encounter an error saying: We were unable to create a zip archive of the packaged application. Normally this indicates a problem running the \\\"zip\\\" utility. Make sure that application is installed and available in your PATH. In this case, it is likely that zip is not installed on your system. We use the Linux zip tool to maintain Linux file permissions. Resolution : To install zip on Linux OS, run the following commands depending on your distribution's package management tool. For distributions using apt-get : sudo apt-get install zip For distributions using yum : sudo yum intall zip After installation, use the command to verify that zip was installed correctly. zip","title":"Missing Dependencies"},{"location":"troubleshooting-guide/missing-dependencies/#missing-dependencies","text":"This section of the troubleshooting guide explains how to determine, diagnose, and fix common issues related to missing external dependencies of AWS.Deploy.Tools","title":"Missing Dependencies"},{"location":"troubleshooting-guide/missing-dependencies/#nodejs-not-installed","text":"Why is this happening : AWS.Deploy.Tools relies on AWS Cloud Development Kit (CDK) to provision resources for your cloud application. AWS CDK requires Node.js to be installed in your machine. See the CDK's FAQs for more information about how it uses Node.js. Minimum required Node.js version >= 14.17.0 Resolution : See here to install Node.js on your system.","title":"Node.js not installed"},{"location":"troubleshooting-guide/missing-dependencies/#docker-not-installed","text":"Why is this happening : AWS.Deploy.Tool requires Docker to be installed in order to perform containerized deployments. Resolution : See here to install Docker for your operating system.","title":"Docker not installed"},{"location":"troubleshooting-guide/missing-dependencies/#zip-utility-not-installed","text":"Why is this happening : Non-container based deployments types (such as deployments to AWS Elastic Beanstalk) create a zip file of the artifacts produced by the dotnet publish command. The zip command line utility is not installed by default on some Linux distributions. If you are deploying using a non-container based option, you may encounter an error saying: We were unable to create a zip archive of the packaged application. Normally this indicates a problem running the \\\"zip\\\" utility. Make sure that application is installed and available in your PATH. In this case, it is likely that zip is not installed on your system. We use the Linux zip tool to maintain Linux file permissions. Resolution : To install zip on Linux OS, run the following commands depending on your distribution's package management tool. For distributions using apt-get : sudo apt-get install zip For distributions using yum : sudo yum intall zip After installation, use the command to verify that zip was installed correctly. zip","title":"Zip utility not installed"},{"location":"tutorials/custom-project/","text":"Adding DynamoDB table to your deployment project In this tutorial, we will create and customize a deployment project to deploy a web application that uses AWS DynamoDB table as the backend store to Amazon Elastic Container Service (ECS). We will then add the deployment project to the source control and share with the team for future deployments. Tasks we will accomplish: Create a new web application called Acme.WebApp Generate a deployment project using a built-in recipe. Customize the deployment project's recipe file to allow the user to configure DynamoDB table. Modify the CDK project to add the new DynamoDB setting options. Modify the CDK project to create the DynamoDB table. Pass the DynamoDB table name to the application code using the environment variable so that our application can read to know which table to use. Add the deployment project to source control. Deploy our Acme.WebApp application using custom deployment project. Note: This tutorial is not concerned with the application logic. You can replace the sample Acme.WebApp used in this tutorial with any other web application.*** Step 1: Create a new web application In your command prompt, run the following command to create your app: dotnet new webapp -o Acme.WebApp -f net6.0 Step 2: Generate a deployment project Navigate to the Acme.WebApp project directory and run the following command to generate a deployment project: dotnet aws deployment-project generate --output ../Acme.WebApp.DeploymentProject --project-display-name \"ASP.NET Core app with DynamoDB\" The --project-display-name switch above configures the name of the recommendation that is shown in the deploy tool when deploying the application project. The AWS Deploy Tool will analyze the Acme.WebApp project and display which built-in recipes can be used as the starting point of the custom deployment project. Recommended Deployment Option ----------------------------- 1: ASP.NET Core App to AWS Elastic Beanstalk on Linux This ASP.NET Core application will be built and deployed to AWS Elastic Beanstalk on Linux. Recommended if you do not want to deploy your application as a container image. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on Linux. 3: ASP.NET Core App to AWS App Runner This ASP.NET Core application will be built as a container image and deployed to AWS App Runner. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on a fully managed environment. 4: ASP.NET Core App to Existing AWS Elastic Beanstalk Environment This ASP.NET Core application will be built and deployed to existing AWS Elastic Beanstalk environment. Recommended if you do not want to deploy your application as a container image. Choose deployment option (recommended default: 1) Pick the option #2 that says \"ASP.NET Core App to Amazon ECS using AWS Fargate\". Acme.WebApp.DeploymentProject is created in a sibling directory to the application project. If you are using Visual Studio, add the new Acme.WebApp.DeploymentProject project to your solution. Step 3: Add DynamoDB settings to the recipe file To give the team members, who will use our deployment project, the choice to either select an existing DynamoDB table or create a new table during deployment, we will add several new settings to our deployment project's recipe definition. Open the Acme.WebApp.DeploymentProject.recipe file located in the deployment project directory in your JSON editor of choice. Go to the OptionSettings section that contains the settings users can use to configure their project. Create a new \"Object\" option setting called Backend to group all of our new settings using the snippet below. When users configure their deployment, this option will be displayed in the \"General\" category. \"OptionSettings\": [ ... { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ ] }, ... } Now we will create child option settings to configure DynamoDB settings. The first is a setting to determine if we should create a new table or not. This setting is a Bool type which is defaulted to true . As a best practice the Updatable setting is set to false to protect users from accidentally deleting the table when redeploying in the future. Add the following snippet to the ChildOptionSettings of the new Backend option we just greated: \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, ... ] If the user unchecks the CreateNewTable setting, we need to give them the choice to select an existing table. This ExistingTableName setting is a \"String\" type that will store the name of an existing DynamoDB table to use as the backend store. Add the following snippet to the ChildOptionSettings of the new Backend option: \"ChildOptionSettings\": [ ... { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] Let us take a deeper dive into the properties for the ExistingTableName setting. TypeHint - Set to DynamoDBTableName which lets the deployment tool know this String type is for the name of a DynamoDB table. The deploy tool uses this information to show users a list of tables to pick from instead of a text-box. Updatable - Since modifying the name of an existing table is not a destructive change, we will allow this field to be updated during redeployments. DependsOn - This setting will only be visible if the previous CreateNewTable setting is set to false . Notice how the Id is the full name of the setting including the parent \"Object\" setting Backend . Validators - This attaches validators to make sure that the user-provided name matches the regex for valid table names and that the name meets the required minimum and maximum lengths. Adding validators provides feedback to users when invalid values are provided in either the CLI or Visual Studio. Here is the full snippet of the Backend Object option setting with the child settings: { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] } Step 4. Add new setting options to the CDK project When CDK project is executed, all settings collected from the user are passed and deserialized into the Configuration type. Now we need to customize the CDK project to store the new setting options by modifying the Configuration type. Create a new class called BackendConfiguration in the Configurations directory. Below is the code for this new type with the properties for CreateNewTable and ExistingTableName . Note: The .NET CDK projects generated by the AWS Deploy Tool have the C# feature Nullable enabled in the project file by default. If you do not want this feature enabled, edit the .csproj file and remove the Nullable project from the PropertyGroup.*** namespace Acme.WebApp.DeploymentProject.Configurations { public class BackendConfiguration { public bool CreateNewTable { get; set; } public string ExistingTableName { get; set; } /// A parameterless constructor is needed for <see cref=\"Microsoft.Extensions.Configuration.ConfigurationBuilder\"/> /// or the classes will fail to initialize. /// The warnings are disabled since a parameterless constructor will allow non-nullable properties to be initialized with null values. #nullable disable warnings public BackendConfiguration() { } #nullable restore warnings public BackendConfiguration( bool createNewTable, string existingTableName) { CreateNewTable = createNewTable; ExistingTableName = existingTableName; } } } In the Configuration.cs file, add a new property for our new backend settings. namespace Acme.WebApp.DeploymentProject.Configurations { public partial class Configuration { public BackendConfiguration Backend { get; set; } = new BackendConfiguration(); } } Notice that the Backend property was added to the partial class that is not in the Generated directory. In both the Configuration and BackendConfiguration types, the property names match the setting ids used in the recipe file. This is important for the data to be property deserialized. Step 5. Add DynamoDB table to the CDK project Note: The AppStack class is the recommended place to customize the AWS resources. Modify the constructor of the AppStack class to check if CreateNewTable is set to true. Then use the Amazon.CDK.AWS.DynamoDB CDK construct to create a table as part of the CloudFormation stack. using Amazon.CDK.AWS.DynamoDB; namespace Acme.WebApp.DeploymentProject { public class AppStack : Stack { private readonly Configuration _configuration; private Table? _ddbBackend; internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; if(_configuration.Backend.CreateNewTable == true) { var backendProps = new TableProps { RemovalPolicy = RemovalPolicy.DESTROY, PartitionKey = new Amazon.CDK.AWS.DynamoDB.Attribute { Name = \"Id\", Type = AttributeType.STRING }, BillingMode = BillingMode.PAY_PER_REQUEST, }; _ddbBackend = new Table(this, \"Backend\", backendProps); } var generatedRecipe = new Recipe(this, props.RecipeProps); } Notice that in the snippet above the table is created before the] Recipe construct. The Recipe construct has all AWS resources that are part of the original built-in ECS recipe that the deployment project was created from. Step 6: Pass the DynamoDB table name to the application code Now that we have our DynamoDB table, we need to pass the table name into our application code. We will do it by setting an environment variable that the application code will read in the CustomizeCDKProps of the AppStack class. CustomizeCDKProps is a callback method that gets called for each AWS resource about to be created from the Recipe construct. To know which AWS resource is about to be created, compare the evnt.ResourceLogicalName property to the public property name on the Recipe construct. The built-in recipes are written to make sure the resource logical name is the same as the public property name. In our scenario we are looking to see if the AppContainerDefinition is about to be created. When we determine that the callback is for AppContainerDefinition then we cast the evnt.Props to the corresponding property object for AppContainerDefinition , in this case ContainerDefinitionOptions . From ContainerDefinitionOptions we can set the table name in an environment variable. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { // Example of how to customize the container image definition to include environment variables to the running applications. // if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.AppContainerDefinition))) { if (evnt.Props is ContainerDefinitionOptions props) { if (props.Environment == null) props.Environment = new Dictionary<string, string>(); if(_ddbBackend != null) { props.Environment[\"BACKEND_TABLE\"] = _ddbBackend.TableName; } else { props.Environment[\"BACKEND_TABLE\"] = _configuration.Backend.ExistingTableName; } } } } Step 6: Add deployment project to the source control Check your customized deployment project in to your source control. This is required to re-deploy your application to existing CloudFormation stacks that were created using custom deployment projects. Step 7: Deploy Acme.WebApp application In your command prompt, run the following command to deploy your application: dotnet aws deploy --project-path . The custom deployment project will be displayed as the recommended option. Recommended Deployment Option ----------------------------- 1: ASP.NET Core app with DynamoDB This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using AWS Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. ... Select deployment option #1. You can now see Backend settings option we customized. When you navigate to the Backend settings, you will be able to choose between using a new table or picking an existing table. ... Current settings (select number to change its value) ---------------------------------------------------- 1. ECS Cluster: AcmeWebApp 2. ECS Service Name: AcmeWebApp-service 3. Backend: Create New DynamoDB Table: True 4. Desired Task Count: 3 5. Application IAM Role: *** Create new *** 6. Virtual Private Cloud (VPC): *** Default *** 7. Environment Variables: 8. ECR Repository Name: acmewebapp ... Note: The AWS Toolkit for Visual Studio will also recognize the custom deployment project. The deployment project will show up as the highest recommended option and the user will also be able to choose between creating a new table or choosing from a drop-down list of available tables in the account that is being deployed to.","title":"Customizing deployment projects"},{"location":"tutorials/custom-project/#adding-dynamodb-table-to-your-deployment-project","text":"In this tutorial, we will create and customize a deployment project to deploy a web application that uses AWS DynamoDB table as the backend store to Amazon Elastic Container Service (ECS). We will then add the deployment project to the source control and share with the team for future deployments. Tasks we will accomplish: Create a new web application called Acme.WebApp Generate a deployment project using a built-in recipe. Customize the deployment project's recipe file to allow the user to configure DynamoDB table. Modify the CDK project to add the new DynamoDB setting options. Modify the CDK project to create the DynamoDB table. Pass the DynamoDB table name to the application code using the environment variable so that our application can read to know which table to use. Add the deployment project to source control. Deploy our Acme.WebApp application using custom deployment project. Note: This tutorial is not concerned with the application logic. You can replace the sample Acme.WebApp used in this tutorial with any other web application.***","title":"Adding DynamoDB table to your deployment project"},{"location":"tutorials/custom-project/#step-1-create-a-new-web-application","text":"In your command prompt, run the following command to create your app: dotnet new webapp -o Acme.WebApp -f net6.0","title":"Step 1: Create a new web application"},{"location":"tutorials/custom-project/#step-2-generate-a-deployment-project","text":"Navigate to the Acme.WebApp project directory and run the following command to generate a deployment project: dotnet aws deployment-project generate --output ../Acme.WebApp.DeploymentProject --project-display-name \"ASP.NET Core app with DynamoDB\" The --project-display-name switch above configures the name of the recommendation that is shown in the deploy tool when deploying the application project. The AWS Deploy Tool will analyze the Acme.WebApp project and display which built-in recipes can be used as the starting point of the custom deployment project. Recommended Deployment Option ----------------------------- 1: ASP.NET Core App to AWS Elastic Beanstalk on Linux This ASP.NET Core application will be built and deployed to AWS Elastic Beanstalk on Linux. Recommended if you do not want to deploy your application as a container image. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on Linux. 3: ASP.NET Core App to AWS App Runner This ASP.NET Core application will be built as a container image and deployed to AWS App Runner. If your project does not contain a Dockerfile, it will be automatically generated. Recommended if you want to deploy your application as a container image on a fully managed environment. 4: ASP.NET Core App to Existing AWS Elastic Beanstalk Environment This ASP.NET Core application will be built and deployed to existing AWS Elastic Beanstalk environment. Recommended if you do not want to deploy your application as a container image. Choose deployment option (recommended default: 1) Pick the option #2 that says \"ASP.NET Core App to Amazon ECS using AWS Fargate\". Acme.WebApp.DeploymentProject is created in a sibling directory to the application project. If you are using Visual Studio, add the new Acme.WebApp.DeploymentProject project to your solution.","title":"Step 2: Generate a deployment project"},{"location":"tutorials/custom-project/#step-3-add-dynamodb-settings-to-the-recipe-file","text":"To give the team members, who will use our deployment project, the choice to either select an existing DynamoDB table or create a new table during deployment, we will add several new settings to our deployment project's recipe definition. Open the Acme.WebApp.DeploymentProject.recipe file located in the deployment project directory in your JSON editor of choice. Go to the OptionSettings section that contains the settings users can use to configure their project. Create a new \"Object\" option setting called Backend to group all of our new settings using the snippet below. When users configure their deployment, this option will be displayed in the \"General\" category. \"OptionSettings\": [ ... { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ ] }, ... } Now we will create child option settings to configure DynamoDB settings. The first is a setting to determine if we should create a new table or not. This setting is a Bool type which is defaulted to true . As a best practice the Updatable setting is set to false to protect users from accidentally deleting the table when redeploying in the future. Add the following snippet to the ChildOptionSettings of the new Backend option we just greated: \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, ... ] If the user unchecks the CreateNewTable setting, we need to give them the choice to select an existing table. This ExistingTableName setting is a \"String\" type that will store the name of an existing DynamoDB table to use as the backend store. Add the following snippet to the ChildOptionSettings of the new Backend option: \"ChildOptionSettings\": [ ... { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] Let us take a deeper dive into the properties for the ExistingTableName setting. TypeHint - Set to DynamoDBTableName which lets the deployment tool know this String type is for the name of a DynamoDB table. The deploy tool uses this information to show users a list of tables to pick from instead of a text-box. Updatable - Since modifying the name of an existing table is not a destructive change, we will allow this field to be updated during redeployments. DependsOn - This setting will only be visible if the previous CreateNewTable setting is set to false . Notice how the Id is the full name of the setting including the parent \"Object\" setting Backend . Validators - This attaches validators to make sure that the user-provided name matches the regex for valid table names and that the name meets the required minimum and maximum lengths. Adding validators provides feedback to users when invalid values are provided in either the CLI or Visual Studio. Here is the full snippet of the Backend Object option setting with the child settings: { \"Id\": \"Backend\", \"Name\": \"Backend\", \"Category\": \"General\", \"Description\": \"Configure the backend store.\", \"Type\": \"Object\", \"AdvancedSetting\": false, \"Updatable\": true, \"ChildOptionSettings\": [ { \"Id\": \"CreateNewTable\", \"Name\": \"Create New DynamoDB Table\", \"Description\": \"Do you want to create a new DynamoDB table for the backend store?\", \"Type\": \"Bool\", \"DefaultValue\": true, \"AdvancedSetting\": false, \"Updatable\": false }, { \"Id\": \"ExistingTableName\", \"Name\": \"Existing DynamoDB Table\", \"Description\": \"Existing DynamoDB table to use as the backend store.\", \"Type\": \"String\", \"TypeHint\": \"DynamoDBTableName\", \"DefaultValue\": \"\", \"AdvancedSetting\": false, \"Updatable\": true, \"DependsOn\": [ { \"Id\": \"Backend.CreateNewTable\", \"Value\": false } ], \"Validators\": [ { \"ValidatorType\": \"Regex\", \"Configuration\": { \"Regex\": \"[a-zA-Z0-9_.-]+\", \"ValidationFailedMessage\": \"Invalid table name.\" } }, { \"ValidatorType\": \"StringLength\", \"Configuration\": { \"MinLength\": 3, \"MaxLength\": 255 } } ] } ] }","title":"Step 3: Add DynamoDB settings to the recipe file"},{"location":"tutorials/custom-project/#step-4-add-new-setting-options-to-the-cdk-project","text":"When CDK project is executed, all settings collected from the user are passed and deserialized into the Configuration type. Now we need to customize the CDK project to store the new setting options by modifying the Configuration type. Create a new class called BackendConfiguration in the Configurations directory. Below is the code for this new type with the properties for CreateNewTable and ExistingTableName . Note: The .NET CDK projects generated by the AWS Deploy Tool have the C# feature Nullable enabled in the project file by default. If you do not want this feature enabled, edit the .csproj file and remove the Nullable project from the PropertyGroup.*** namespace Acme.WebApp.DeploymentProject.Configurations { public class BackendConfiguration { public bool CreateNewTable { get; set; } public string ExistingTableName { get; set; } /// A parameterless constructor is needed for <see cref=\"Microsoft.Extensions.Configuration.ConfigurationBuilder\"/> /// or the classes will fail to initialize. /// The warnings are disabled since a parameterless constructor will allow non-nullable properties to be initialized with null values. #nullable disable warnings public BackendConfiguration() { } #nullable restore warnings public BackendConfiguration( bool createNewTable, string existingTableName) { CreateNewTable = createNewTable; ExistingTableName = existingTableName; } } } In the Configuration.cs file, add a new property for our new backend settings. namespace Acme.WebApp.DeploymentProject.Configurations { public partial class Configuration { public BackendConfiguration Backend { get; set; } = new BackendConfiguration(); } } Notice that the Backend property was added to the partial class that is not in the Generated directory. In both the Configuration and BackendConfiguration types, the property names match the setting ids used in the recipe file. This is important for the data to be property deserialized.","title":"Step 4. Add new setting options to the CDK project"},{"location":"tutorials/custom-project/#step-5-add-dynamodb-table-to-the-cdk-project","text":"Note: The AppStack class is the recommended place to customize the AWS resources. Modify the constructor of the AppStack class to check if CreateNewTable is set to true. Then use the Amazon.CDK.AWS.DynamoDB CDK construct to create a table as part of the CloudFormation stack. using Amazon.CDK.AWS.DynamoDB; namespace Acme.WebApp.DeploymentProject { public class AppStack : Stack { private readonly Configuration _configuration; private Table? _ddbBackend; internal AppStack(Construct scope, IDeployToolStackProps<Configuration> props) : base(scope, props.StackName, props) { _configuration = props.RecipeProps.Settings; // Setup callback for generated construct to provide access to customize CDK properties before creating constructs. CDKRecipeCustomizer<Recipe>.CustomizeCDKProps += CustomizeCDKProps; if(_configuration.Backend.CreateNewTable == true) { var backendProps = new TableProps { RemovalPolicy = RemovalPolicy.DESTROY, PartitionKey = new Amazon.CDK.AWS.DynamoDB.Attribute { Name = \"Id\", Type = AttributeType.STRING }, BillingMode = BillingMode.PAY_PER_REQUEST, }; _ddbBackend = new Table(this, \"Backend\", backendProps); } var generatedRecipe = new Recipe(this, props.RecipeProps); } Notice that in the snippet above the table is created before the] Recipe construct. The Recipe construct has all AWS resources that are part of the original built-in ECS recipe that the deployment project was created from.","title":"Step 5. Add DynamoDB table to the CDK project"},{"location":"tutorials/custom-project/#step-6-pass-the-dynamodb-table-name-to-the-application-code","text":"Now that we have our DynamoDB table, we need to pass the table name into our application code. We will do it by setting an environment variable that the application code will read in the CustomizeCDKProps of the AppStack class. CustomizeCDKProps is a callback method that gets called for each AWS resource about to be created from the Recipe construct. To know which AWS resource is about to be created, compare the evnt.ResourceLogicalName property to the public property name on the Recipe construct. The built-in recipes are written to make sure the resource logical name is the same as the public property name. In our scenario we are looking to see if the AppContainerDefinition is about to be created. When we determine that the callback is for AppContainerDefinition then we cast the evnt.Props to the corresponding property object for AppContainerDefinition , in this case ContainerDefinitionOptions . From ContainerDefinitionOptions we can set the table name in an environment variable. private void CustomizeCDKProps(CustomizePropsEventArgs<Recipe> evnt) { // Example of how to customize the container image definition to include environment variables to the running applications. // if (string.Equals(evnt.ResourceLogicalName, nameof(evnt.Construct.AppContainerDefinition))) { if (evnt.Props is ContainerDefinitionOptions props) { if (props.Environment == null) props.Environment = new Dictionary<string, string>(); if(_ddbBackend != null) { props.Environment[\"BACKEND_TABLE\"] = _ddbBackend.TableName; } else { props.Environment[\"BACKEND_TABLE\"] = _configuration.Backend.ExistingTableName; } } } }","title":"Step 6: Pass the DynamoDB table name to the application code"},{"location":"tutorials/custom-project/#step-6-add-deployment-project-to-the-source-control","text":"Check your customized deployment project in to your source control. This is required to re-deploy your application to existing CloudFormation stacks that were created using custom deployment projects.","title":"Step 6: Add deployment project to the source control"},{"location":"tutorials/custom-project/#step-7-deploy-acmewebapp-application","text":"In your command prompt, run the following command to deploy your application: dotnet aws deploy --project-path . The custom deployment project will be displayed as the recommended option. Recommended Deployment Option ----------------------------- 1: ASP.NET Core app with DynamoDB This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. Additional Deployment Options ------------------------------ 2: ASP.NET Core App to Amazon ECS using AWS Fargate This ASP.NET Core application will be deployed to Amazon Elastic Container Service (Amazon ECS) with compute power managed by AWS Fargate compute engine. If your project does not contain a Dockerfile, it will be automatically generated, otherwise an existing Dockerfile will be used. Recommended if you want to deploy your application as a container image on Linux. ... Select deployment option #1. You can now see Backend settings option we customized. When you navigate to the Backend settings, you will be able to choose between using a new table or picking an existing table. ... Current settings (select number to change its value) ---------------------------------------------------- 1. ECS Cluster: AcmeWebApp 2. ECS Service Name: AcmeWebApp-service 3. Backend: Create New DynamoDB Table: True 4. Desired Task Count: 3 5. Application IAM Role: *** Create new *** 6. Virtual Private Cloud (VPC): *** Default *** 7. Environment Variables: 8. ECR Repository Name: acmewebapp ... Note: The AWS Toolkit for Visual Studio will also recognize the custom deployment project. The deployment project will show up as the highest recommended option and the user will also be able to choose between creating a new table or choosing from a drop-down list of available tables in the account that is being deployed to.","title":"Step 7: Deploy Acme.WebApp application"}]}